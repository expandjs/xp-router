{"version":3,"sources":["../browserify/node_modules/browser-pack/_prelude.js","index","lib/index.js","node_modules/path-to-regexp/index.js","node_modules/director/build/director.js","node_modules/path-to-regexp/node_modules/isarray/index.js"],"names":["global","parser","require","XP","director","isBrowser","Router","http","module","exports","XPRouter","Class","initialize","server","self","this","_adaptee","_server","configure","recurse","on","_handleRequest","bind","init","initialized","path","method","callback","isFunction","assertArgument","isString","keys","pluck","toLowerCase","zipObject","arguments","assign","req","params","res","set","val","route","get","getRoute","enumerable","validate","isObject","isDefined","chunks","chunk","push","body","join","dispatch","writeHead","end","window","parse","str","tokens","key","index","PATH_REGEXP","exec","m","escaped","offset","slice","length","prefix","name","capture","group","suffix","asterisk","repeat","optional","delimiter","pattern","escapeGroup","substr","compile","tokensToFunction","matches","Array","i","RegExp","obj","data","token","segment","value","TypeError","isarray","j","encodeURIComponent","test","escapeString","replace","attachKeys","re","flags","options","sensitive","regexpToRegexp","groups","source","match","arrayToRegexp","parts","pathToRegexp","regexp","stringToRegexp","tokensToRegExp","strict","lastToken","endsWithSlash","dlocHashEmpty","dloc","hash","_every","arr","iterator","_flatten","flat","n","concat","_asyncEverySeries","completed","iterate","err","paramifyString","mod","param","hasOwnProperty","regifyString","last","out","captures","terminator","routes","start","stop","left","right","toString","indexOf","tmp","document","location","listener","mode","history","check","h","onHashChanged","fire","onpopstate","onhashchange","fn","onchange","onChangeEvent","l","listeners","undefined","documentMode","setTimeout","frame","createElement","id","style","display","appendChild","writeFrame","attachEvent","event","propertyName","setInterval","destroy","splice","setHash","s","pushState","title","f","getElementById","d","contentDocument","contentWindow","open","write","close","syncHash","_hash","methods","scope","_methods","_insert","insert","insertEx","historySupport","mount","prototype","r","routeTo","handler","newURL","url","getPath","charAt","convert_hash_in_init","replaceState","run_in_init","explode","v","split","setRoute","parent","once","apply","ret","pathname","QUERY_SEPARATOR","async","notfound","resource","html5history","run_handler_in_init","every","after","before","matcher","compiled","isArray","forEach","p","routesFn","call","updateAndInvoke","fns","invoke","runlist","traverse","invoked","_invoked","reverse","thisArg","next","filter","filterRoutes","deepCopy","result","applyFilter","newRoutes","matched","current","exact","Boolean","methodType","parentType","nested","part","shift","Error","extend","extra","len","insertOrMount","local","rename","routeType","isRoute","Object"],"mappings":"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","file":"bundle.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","module.exports=require(\"./lib\");","/*jslint browser: true, devel: true, node: true, ass: true, nomen: true, unparam: true, indent: 4 */\n\n/**\n * @license\n * Copyright (c) 2015 The ExpandJS authors. All rights reserved.\n * This code may only be used under the BSD style license found at https://expandjs.github.io/LICENSE.txt\n * The complete set of authors may be found at https://expandjs.github.io/AUTHORS.txt\n * The complete set of contributors may be found at https://expandjs.github.io/CONTRIBUTORS.txt\n */\n(function (global) {\n    \"use strict\";\n\n    // Vars\n    var parser   = require('path-to-regexp'),\n        XP       = global.XP || require('expandjs'),\n        director = XP.isBrowser() ? require('director/build/director') : require('director'),\n        Router   = XP.isBrowser() ? global.Router : director.http.Router;\n\n    /*********************************************************************/\n\n    /**\n     * This class is used to perform client/server side routing.\n     *\n     * @class XPRouter\n     * @description This class is used to perform client/server side routing\n     */\n    module.exports = global.XPRouter = new XP.Class('XPRouter', {\n\n        /**\n         * @constructs\n         * @param {Object} [server]\n         */\n        initialize: function (server) {\n\n            // Vars\n            var self = this;\n\n            // Setting\n            self._adaptee = new Router();\n            self._server  = XP.isBrowser() ? null : server;\n\n            // Configuring\n            self._adaptee.configure({recurse: false});\n\n            // Listening\n            if (self._server) { self._server.on('request', self._handleRequest.bind(self)); }\n        },\n\n        /*********************************************************************/\n\n        /**\n         * TODO DOC\n         *\n         * @method init\n         * @returns {boolean}\n         */\n        init: function () {\n\n            // Vars\n            var self = this;\n\n            // Initializing\n            if (!self.initialized && XP.isBrowser()) { self._adaptee.init(); }\n\n            // Setting\n            return self.initialized = true;\n        },\n\n        /**\n         * TODO DOC\n         *\n         * @method on\n         * @param {string} path\n         * @param {string} [method = \"GET\"]\n         * @param {Function} callback\n         * @returns {Object}\n         */\n        on: function (path, method, callback) {\n\n            // Preparing\n            if (XP.isFunction(method)) { callback = method; method = 'GET'; }\n\n            // Asserting\n            XP.assertArgument(XP.isString(path, true), 1, 'string');\n            XP.assertArgument(XP.isString(method, true), 2, 'string');\n            XP.assertArgument(XP.isFunction(callback), 3, 'Function');\n\n            // Vars\n            var self = this,\n                keys = [];\n\n            // Checking\n            if (self.initialized) { return self; }\n\n            // Overriding\n            keys   = XP.pluck(parser(path, keys) && keys, 'name');\n            method = XP.isBrowser() ? 'on' : method.toLowerCase();\n\n            // Listening\n            if (XP.isBrowser()) {\n                self._adaptee[method](path, function () { callback(XP.zipObject(keys, arguments)); });\n            } else {\n                self._adaptee[method](path, function () { callback(XP.assign(this.req, {params: XP.zipObject(keys, arguments)}), this.res); });\n            }\n\n            return self;\n        },\n\n        /*********************************************************************/\n\n        /**\n         * TODO DOC\n         *\n         * @property initialized\n         * @type boolean\n         * @readonly\n         */\n        initialized: {\n            set: function (val) { return this.initialized || !!val; }\n        },\n\n        /**\n         * TODO DOC\n         *\n         * @property route\n         * @type Array\n         * @readonly\n         */\n        route: {\n            get: function () { return (this.initialized && this._adaptee.getRoute()) || null; }\n        },\n\n        /*********************************************************************/\n\n        /**\n         * TODO DOC\n         *\n         * @property _adaptee\n         * @type Object\n         * @private\n         */\n        _adaptee: {\n            enumerable: false,\n            set: function (val) { return this._adaptee || val; },\n            validate: function (val) { return !XP.isObject(val) && 'Object'; }\n        },\n\n        /**\n         * TODO DOC\n         *\n         * @property _server\n         * @type Object\n         * @private\n         */\n        _server: {\n            enumerable: false,\n            set: function (val) { return XP.isDefined(this._server) ? this._server : val; },\n            validate: function (val) { return !XP.isBrowser() && !XP.isObject(val) && 'Object'; }\n        },\n\n        /*********************************************************************/\n\n        // HANDLER\n        _handleRequest: function (req, res) {\n\n            // Vars\n            var self   = this,\n                chunks = [];\n\n            // Listening\n            req.on('data', function (chunk) { chunks.push(chunk); });\n            req.on('end', function () { req.body = XP.join(chunks); });\n\n            // Dispatching\n            self._adaptee.dispatch(req, res, function () {\n                res.writeHead(404);\n                res.end();\n            });\n        }\n    });\n\n}(typeof window !== \"undefined\" ? window : global));","var isarray = require('isarray')\n\n/**\n * Expose `pathToRegexp`.\n */\nmodule.exports = pathToRegexp\nmodule.exports.parse = parse\nmodule.exports.compile = compile\nmodule.exports.tokensToFunction = tokensToFunction\nmodule.exports.tokensToRegExp = tokensToRegExp\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n  // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n  // \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n  '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^()])+)\\\\))([+*?])?|(\\\\*))'\n].join('|'), 'g')\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {String} str\n * @return {Array}\n */\nfunction parse (str) {\n  var tokens = []\n  var key = 0\n  var index = 0\n  var path = ''\n  var res\n\n  while ((res = PATH_REGEXP.exec(str)) != null) {\n    var m = res[0]\n    var escaped = res[1]\n    var offset = res.index\n    path += str.slice(index, offset)\n    index = offset + m.length\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1]\n      continue\n    }\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path)\n      path = ''\n    }\n\n    var prefix = res[2]\n    var name = res[3]\n    var capture = res[4]\n    var group = res[5]\n    var suffix = res[6]\n    var asterisk = res[7]\n\n    var repeat = suffix === '+' || suffix === '*'\n    var optional = suffix === '?' || suffix === '*'\n    var delimiter = prefix || '/'\n    var pattern = capture || group || (asterisk ? '.*' : '[^' + delimiter + ']+?')\n\n    tokens.push({\n      name: name || key++,\n      prefix: prefix || '',\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      pattern: escapeGroup(pattern)\n    })\n  }\n\n  // Match any characters still remaining.\n  if (index < str.length) {\n    path += str.substr(index)\n  }\n\n  // If the path exists, push it onto the end.\n  if (path) {\n    tokens.push(path)\n  }\n\n  return tokens\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {String}   str\n * @return {Function}\n */\nfunction compile (str) {\n  return tokensToFunction(parse(str))\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction (tokens) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length)\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^' + tokens[i].pattern + '$')\n    }\n  }\n\n  return function (obj) {\n    var path = ''\n    var data = obj || {}\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i]\n\n      if (typeof token === 'string') {\n        path += token\n\n        continue\n      }\n\n      var value = data[token.name]\n      var segment\n\n      if (value == null) {\n        if (token.optional) {\n          continue\n        } else {\n          throw new TypeError('Expected \"' + token.name + '\" to be defined')\n        }\n      }\n\n      if (isarray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received \"' + value + '\"')\n        }\n\n        if (value.length === 0) {\n          if (token.optional) {\n            continue\n          } else {\n            throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n          }\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encodeURIComponent(value[j])\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment\n        }\n\n        continue\n      }\n\n      segment = encodeURIComponent(value)\n\n      if (!matches[i].test(segment)) {\n        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n      }\n\n      path += token.prefix + segment\n    }\n\n    return path\n  }\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {String} str\n * @return {String}\n */\nfunction escapeString (str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|\\/])/g, '\\\\$1')\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {String} group\n * @return {String}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$\\/()])/g, '\\\\$1')\n}\n\n/**\n * Attach the keys as a property of the regexp.\n *\n * @param  {RegExp} re\n * @param  {Array}  keys\n * @return {RegExp}\n */\nfunction attachKeys (re, keys) {\n  re.keys = keys\n  return re\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {String}\n */\nfunction flags (options) {\n  return options.sensitive ? '' : 'i'\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {RegExp} path\n * @param  {Array}  keys\n * @return {RegExp}\n */\nfunction regexpToRegexp (path, keys) {\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g)\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        pattern: null\n      })\n    }\n  }\n\n  return attachKeys(path, keys)\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {Array}  path\n * @param  {Array}  keys\n * @param  {Object} options\n * @return {RegExp}\n */\nfunction arrayToRegexp (path, keys, options) {\n  var parts = []\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source)\n  }\n\n  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))\n\n  return attachKeys(regexp, keys)\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {String} path\n * @param  {Array}  keys\n * @param  {Object} options\n * @return {RegExp}\n */\nfunction stringToRegexp (path, keys, options) {\n  var tokens = parse(path)\n  var re = tokensToRegExp(tokens, options)\n\n  // Attach keys back to the regexp.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] !== 'string') {\n      keys.push(tokens[i])\n    }\n  }\n\n  return attachKeys(re, keys)\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {Array}  tokens\n * @param  {Array}  keys\n * @param  {Object} options\n * @return {RegExp}\n */\nfunction tokensToRegExp (tokens, options) {\n  options = options || {}\n\n  var strict = options.strict\n  var end = options.end !== false\n  var route = ''\n  var lastToken = tokens[tokens.length - 1]\n  var endsWithSlash = typeof lastToken === 'string' && /\\/$/.test(lastToken)\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n\n    if (typeof token === 'string') {\n      route += escapeString(token)\n    } else {\n      var prefix = escapeString(token.prefix)\n      var capture = token.pattern\n\n      if (token.repeat) {\n        capture += '(?:' + prefix + capture + ')*'\n      }\n\n      if (token.optional) {\n        if (prefix) {\n          capture = '(?:' + prefix + '(' + capture + '))?'\n        } else {\n          capture = '(' + capture + ')?'\n        }\n      } else {\n        capture = prefix + '(' + capture + ')'\n      }\n\n      route += capture\n    }\n  }\n\n  // In non-strict mode we allow a slash at the end of match. If the path to\n  // match already ends with a slash, we remove it for consistency. The slash\n  // is valid at the end of a path match, not in the middle. This is important\n  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n  if (!strict) {\n    route = (endsWithSlash ? route.slice(0, -2) : route) + '(?:\\\\/(?=$))?'\n  }\n\n  if (end) {\n    route += '$'\n  } else {\n    // In non-ending mode, we need the capturing groups to match as much as\n    // possible by using a positive lookahead to the end or next path segment.\n    route += strict && endsWithSlash ? '' : '(?=\\\\/|$)'\n  }\n\n  return new RegExp('^' + route, flags(options))\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(String|RegExp|Array)} path\n * @param  {Array}                 [keys]\n * @param  {Object}                [options]\n * @return {RegExp}\n */\nfunction pathToRegexp (path, keys, options) {\n  keys = keys || []\n\n  if (!isarray(keys)) {\n    options = keys\n    keys = []\n  } else if (!options) {\n    options = {}\n  }\n\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, keys, options)\n  }\n\n  if (isarray(path)) {\n    return arrayToRegexp(path, keys, options)\n  }\n\n  return stringToRegexp(path, keys, options)\n}\n","\n\n//\n// Generated on Tue Dec 16 2014 12:13:47 GMT+0100 (CET) by Charlie Robbins, Paolo Fragomeni & the Contributors (Using Codesurgeon).\n// Version 1.2.6\n//\n\n(function (exports) {\n\n/*\n * browser.js: Browser specific functionality for director.\n *\n * (C) 2011, Charlie Robbins, Paolo Fragomeni, & the Contributors.\n * MIT LICENSE\n *\n */\n\nvar dloc = document.location;\n\nfunction dlocHashEmpty() {\n  // Non-IE browsers return '' when the address bar shows '#'; Director's logic\n  // assumes both mean empty.\n  return dloc.hash === '' || dloc.hash === '#';\n}\n\nvar listener = {\n  mode: 'modern',\n  hash: dloc.hash,\n  history: false,\n\n  check: function () {\n    var h = dloc.hash;\n    if (h != this.hash) {\n      this.hash = h;\n      this.onHashChanged();\n    }\n  },\n\n  fire: function () {\n    if (this.mode === 'modern') {\n      this.history === true ? window.onpopstate() : window.onhashchange();\n    }\n    else {\n      this.onHashChanged();\n    }\n  },\n\n  init: function (fn, history) {\n    var self = this;\n    this.history = history;\n\n    if (!Router.listeners) {\n      Router.listeners = [];\n    }\n\n    function onchange(onChangeEvent) {\n      for (var i = 0, l = Router.listeners.length; i < l; i++) {\n        Router.listeners[i](onChangeEvent);\n      }\n    }\n\n    //note IE8 is being counted as 'modern' because it has the hashchange event\n    if ('onhashchange' in window && (document.documentMode === undefined\n      || document.documentMode > 7)) {\n      // At least for now HTML5 history is available for 'modern' browsers only\n      if (this.history === true) {\n        // There is an old bug in Chrome that causes onpopstate to fire even\n        // upon initial page load. Since the handler is run manually in init(),\n        // this would cause Chrome to run it twise. Currently the only\n        // workaround seems to be to set the handler after the initial page load\n        // http://code.google.com/p/chromium/issues/detail?id=63040\n        setTimeout(function() {\n          window.onpopstate = onchange;\n        }, 500);\n      }\n      else {\n        window.onhashchange = onchange;\n      }\n      this.mode = 'modern';\n    }\n    else {\n      //\n      // IE support, based on a concept by Erik Arvidson ...\n      //\n      var frame = document.createElement('iframe');\n      frame.id = 'state-frame';\n      frame.style.display = 'none';\n      document.body.appendChild(frame);\n      this.writeFrame('');\n\n      if ('onpropertychange' in document && 'attachEvent' in document) {\n        document.attachEvent('onpropertychange', function () {\n          if (event.propertyName === 'location') {\n            self.check();\n          }\n        });\n      }\n\n      window.setInterval(function () { self.check(); }, 50);\n\n      this.onHashChanged = onchange;\n      this.mode = 'legacy';\n    }\n\n    Router.listeners.push(fn);\n\n    return this.mode;\n  },\n\n  destroy: function (fn) {\n    if (!Router || !Router.listeners) {\n      return;\n    }\n\n    var listeners = Router.listeners;\n\n    for (var i = listeners.length - 1; i >= 0; i--) {\n      if (listeners[i] === fn) {\n        listeners.splice(i, 1);\n      }\n    }\n  },\n\n  setHash: function (s) {\n    // Mozilla always adds an entry to the history\n    if (this.mode === 'legacy') {\n      this.writeFrame(s);\n    }\n\n    if (this.history === true) {\n      window.history.pushState({}, document.title, s);\n      // Fire an onpopstate event manually since pushing does not obviously\n      // trigger the pop event.\n      this.fire();\n    } else {\n      dloc.hash = (s[0] === '/') ? s : '/' + s;\n    }\n    return this;\n  },\n\n  writeFrame: function (s) {\n    // IE support...\n    var f = document.getElementById('state-frame');\n    var d = f.contentDocument || f.contentWindow.document;\n    d.open();\n    d.write(\"<script>_hash = '\" + s + \"'; onload = parent.listener.syncHash;<script>\");\n    d.close();\n  },\n\n  syncHash: function () {\n    // IE support...\n    var s = this._hash;\n    if (s != dloc.hash) {\n      dloc.hash = s;\n    }\n    return this;\n  },\n\n  onHashChanged: function () {}\n};\n\nvar Router = exports.Router = function (routes) {\n  if (!(this instanceof Router)) return new Router(routes);\n\n  this.params   = {};\n  this.routes   = {};\n  this.methods  = ['on', 'once', 'after', 'before'];\n  this.scope    = [];\n  this._methods = {};\n\n  this._insert = this.insert;\n  this.insert = this.insertEx;\n\n  this.historySupport = (window.history != null ? window.history.pushState : null) != null\n\n  this.configure();\n  this.mount(routes || {});\n};\n\nRouter.prototype.init = function (r) {\n  var self = this\n    , routeTo;\n  this.handler = function(onChangeEvent) {\n    var newURL = onChangeEvent && onChangeEvent.newURL || window.location.hash;\n    var url = self.history === true ? self.getPath() : newURL.replace(/.*#/, '');\n    self.dispatch('on', url.charAt(0) === '/' ? url : '/' + url);\n  };\n\n  listener.init(this.handler, this.history);\n\n  if (this.history === false) {\n    if (dlocHashEmpty() && r) {\n      dloc.hash = r;\n    } else if (!dlocHashEmpty()) {\n      self.dispatch('on', '/' + dloc.hash.replace(/^(#\\/|#|\\/)/, ''));\n    }\n  }\n  else {\n    if (this.convert_hash_in_init) {\n      // Use hash as route\n      routeTo = dlocHashEmpty() && r ? r : !dlocHashEmpty() ? dloc.hash.replace(/^#/, '') : null;\n      if (routeTo) {\n        window.history.replaceState({}, document.title, routeTo);\n      }\n    }\n    else {\n      // Use canonical url\n      routeTo = this.getPath();\n    }\n\n    // Router has been initialized, but due to the chrome bug it will not\n    // yet actually route HTML5 history state changes. Thus, decide if should route.\n    if (routeTo || this.run_in_init === true) {\n      this.handler();\n    }\n  }\n\n  return this;\n};\n\nRouter.prototype.explode = function () {\n  var v = this.history === true ? this.getPath() : dloc.hash;\n  if (v.charAt(1) === '/') { v=v.slice(1) }\n  return v.slice(1, v.length).split(\"/\");\n};\n\nRouter.prototype.setRoute = function (i, v, val) {\n  var url = this.explode();\n\n  if (typeof i === 'number' && typeof v === 'string') {\n    url[i] = v;\n  }\n  else if (typeof val === 'string') {\n    url.splice(i, v, s);\n  }\n  else {\n    url = [i];\n  }\n\n  listener.setHash(url.join('/'));\n  return url;\n};\n\n//\n// ### function insertEx(method, path, route, parent)\n// #### @method {string} Method to insert the specific `route`.\n// #### @path {Array} Parsed path to insert the `route` at.\n// #### @route {Array|function} Route handlers to insert.\n// #### @parent {Object} **Optional** Parent \"routes\" to insert into.\n// insert a callback that will only occur once per the matched route.\n//\nRouter.prototype.insertEx = function(method, path, route, parent) {\n  if (method === \"once\") {\n    method = \"on\";\n    route = function(route) {\n      var once = false;\n      return function() {\n        if (once) return;\n        once = true;\n        return route.apply(this, arguments);\n      };\n    }(route);\n  }\n  return this._insert(method, path, route, parent);\n};\n\nRouter.prototype.getRoute = function (v) {\n  var ret = v;\n\n  if (typeof v === \"number\") {\n    ret = this.explode()[v];\n  }\n  else if (typeof v === \"string\"){\n    var h = this.explode();\n    ret = h.indexOf(v);\n  }\n  else {\n    ret = this.explode();\n  }\n\n  return ret;\n};\n\nRouter.prototype.destroy = function () {\n  listener.destroy(this.handler);\n  return this;\n};\n\nRouter.prototype.getPath = function () {\n  var path = window.location.pathname;\n  if (path.substr(0, 1) !== '/') {\n    path = '/' + path;\n  }\n  return path;\n};\nfunction _every(arr, iterator) {\n  for (var i = 0; i < arr.length; i += 1) {\n    if (iterator(arr[i], i, arr) === false) {\n      return;\n    }\n  }\n}\n\nfunction _flatten(arr) {\n  var flat = [];\n  for (var i = 0, n = arr.length; i < n; i++) {\n    flat = flat.concat(arr[i]);\n  }\n  return flat;\n}\n\nfunction _asyncEverySeries(arr, iterator, callback) {\n  if (!arr.length) {\n    return callback();\n  }\n  var completed = 0;\n  (function iterate() {\n    iterator(arr[completed], function(err) {\n      if (err || err === false) {\n        callback(err);\n        callback = function() {};\n      } else {\n        completed += 1;\n        if (completed === arr.length) {\n          callback();\n        } else {\n          iterate();\n        }\n      }\n    });\n  })();\n}\n\nfunction paramifyString(str, params, mod) {\n  mod = str;\n  for (var param in params) {\n    if (params.hasOwnProperty(param)) {\n      mod = params[param](str);\n      if (mod !== str) {\n        break;\n      }\n    }\n  }\n  return mod === str ? \"([._a-zA-Z0-9-%()]+)\" : mod;\n}\n\nfunction regifyString(str, params) {\n  var matches, last = 0, out = \"\";\n  while (matches = str.substr(last).match(/[^\\w\\d\\- %@&]*\\*[^\\w\\d\\- %@&]*/)) {\n    last = matches.index + matches[0].length;\n    matches[0] = matches[0].replace(/^\\*/, \"([_.()!\\\\ %@&a-zA-Z0-9-]+)\");\n    out += str.substr(0, matches.index) + matches[0];\n  }\n  str = out += str.substr(last);\n  var captures = str.match(/:([^\\/]+)/ig), capture, length;\n  if (captures) {\n    length = captures.length;\n    for (var i = 0; i < length; i++) {\n      capture = captures[i];\n      if (capture.slice(0, 2) === \"::\") {\n        str = capture.slice(1);\n      } else {\n        str = str.replace(capture, paramifyString(capture, params));\n      }\n    }\n  }\n  return str;\n}\n\nfunction terminator(routes, delimiter, start, stop) {\n  var last = 0, left = 0, right = 0, start = (start || \"(\").toString(), stop = (stop || \")\").toString(), i;\n  for (i = 0; i < routes.length; i++) {\n    var chunk = routes[i];\n    if (chunk.indexOf(start, last) > chunk.indexOf(stop, last) || ~chunk.indexOf(start, last) && !~chunk.indexOf(stop, last) || !~chunk.indexOf(start, last) && ~chunk.indexOf(stop, last)) {\n      left = chunk.indexOf(start, last);\n      right = chunk.indexOf(stop, last);\n      if (~left && !~right || !~left && ~right) {\n        var tmp = routes.slice(0, (i || 1) + 1).join(delimiter);\n        routes = [ tmp ].concat(routes.slice((i || 1) + 1));\n      }\n      last = (right > left ? right : left) + 1;\n      i = 0;\n    } else {\n      last = 0;\n    }\n  }\n  return routes;\n}\n\nvar QUERY_SEPARATOR = /\\?.*/;\n\nRouter.prototype.configure = function(options) {\n  options = options || {};\n  for (var i = 0; i < this.methods.length; i++) {\n    this._methods[this.methods[i]] = true;\n  }\n  this.recurse = options.recurse || this.recurse || false;\n  this.async = options.async || false;\n  this.delimiter = options.delimiter || \"/\";\n  this.strict = typeof options.strict === \"undefined\" ? true : options.strict;\n  this.notfound = options.notfound;\n  this.resource = options.resource;\n  this.history = options.html5history && this.historySupport || false;\n  this.run_in_init = this.history === true && options.run_handler_in_init !== false;\n  this.convert_hash_in_init = this.history === true && options.convert_hash_in_init !== false;\n  this.every = {\n    after: options.after || null,\n    before: options.before || null,\n    on: options.on || null\n  };\n  return this;\n};\n\nRouter.prototype.param = function(token, matcher) {\n  if (token[0] !== \":\") {\n    token = \":\" + token;\n  }\n  var compiled = new RegExp(token, \"g\");\n  this.params[token] = function(str) {\n    return str.replace(compiled, matcher.source || matcher);\n  };\n  return this;\n};\n\nRouter.prototype.on = Router.prototype.route = function(method, path, route) {\n  var self = this;\n  if (!route && typeof path == \"function\") {\n    route = path;\n    path = method;\n    method = \"on\";\n  }\n  if (Array.isArray(path)) {\n    return path.forEach(function(p) {\n      self.on(method, p, route);\n    });\n  }\n  if (path.source) {\n    path = path.source.replace(/\\\\\\//ig, \"/\");\n  }\n  if (Array.isArray(method)) {\n    return method.forEach(function(m) {\n      self.on(m.toLowerCase(), path, route);\n    });\n  }\n  path = path.split(new RegExp(this.delimiter));\n  path = terminator(path, this.delimiter);\n  this.insert(method, this.scope.concat(path), route);\n};\n\nRouter.prototype.path = function(path, routesFn) {\n  var self = this, length = this.scope.length;\n  if (path.source) {\n    path = path.source.replace(/\\\\\\//ig, \"/\");\n  }\n  path = path.split(new RegExp(this.delimiter));\n  path = terminator(path, this.delimiter);\n  this.scope = this.scope.concat(path);\n  routesFn.call(this, this);\n  this.scope.splice(length, path.length);\n};\n\nRouter.prototype.dispatch = function(method, path, callback) {\n  var self = this, fns = this.traverse(method, path.replace(QUERY_SEPARATOR, \"\"), this.routes, \"\"), invoked = this._invoked, after;\n  this._invoked = true;\n  if (!fns || fns.length === 0) {\n    this.last = [];\n    if (typeof this.notfound === \"function\") {\n      this.invoke([ this.notfound ], {\n        method: method,\n        path: path\n      }, callback);\n    }\n    return false;\n  }\n  if (this.recurse === \"forward\") {\n    fns = fns.reverse();\n  }\n  function updateAndInvoke() {\n    self.last = fns.after;\n    self.invoke(self.runlist(fns), self, callback);\n  }\n  after = this.every && this.every.after ? [ this.every.after ].concat(this.last) : [ this.last ];\n  if (after && after.length > 0 && invoked) {\n    if (this.async) {\n      this.invoke(after, this, updateAndInvoke);\n    } else {\n      this.invoke(after, this);\n      updateAndInvoke();\n    }\n    return true;\n  }\n  updateAndInvoke();\n  return true;\n};\n\nRouter.prototype.invoke = function(fns, thisArg, callback) {\n  var self = this;\n  var apply;\n  if (this.async) {\n    apply = function(fn, next) {\n      if (Array.isArray(fn)) {\n        return _asyncEverySeries(fn, apply, next);\n      } else if (typeof fn == \"function\") {\n        fn.apply(thisArg, (fns.captures || []).concat(next));\n      }\n    };\n    _asyncEverySeries(fns, apply, function() {\n      if (callback) {\n        callback.apply(thisArg, arguments);\n      }\n    });\n  } else {\n    apply = function(fn) {\n      if (Array.isArray(fn)) {\n        return _every(fn, apply);\n      } else if (typeof fn === \"function\") {\n        return fn.apply(thisArg, fns.captures || []);\n      } else if (typeof fn === \"string\" && self.resource) {\n        self.resource[fn].apply(thisArg, fns.captures || []);\n      }\n    };\n    _every(fns, apply);\n  }\n};\n\nRouter.prototype.traverse = function(method, path, routes, regexp, filter) {\n  var fns = [], current, exact, match, next, that;\n  function filterRoutes(routes) {\n    if (!filter) {\n      return routes;\n    }\n    function deepCopy(source) {\n      var result = [];\n      for (var i = 0; i < source.length; i++) {\n        result[i] = Array.isArray(source[i]) ? deepCopy(source[i]) : source[i];\n      }\n      return result;\n    }\n    function applyFilter(fns) {\n      for (var i = fns.length - 1; i >= 0; i--) {\n        if (Array.isArray(fns[i])) {\n          applyFilter(fns[i]);\n          if (fns[i].length === 0) {\n            fns.splice(i, 1);\n          }\n        } else {\n          if (!filter(fns[i])) {\n            fns.splice(i, 1);\n          }\n        }\n      }\n    }\n    var newRoutes = deepCopy(routes);\n    newRoutes.matched = routes.matched;\n    newRoutes.captures = routes.captures;\n    newRoutes.after = routes.after.filter(filter);\n    applyFilter(newRoutes);\n    return newRoutes;\n  }\n  if (path === this.delimiter && routes[method]) {\n    next = [ [ routes.before, routes[method] ].filter(Boolean) ];\n    next.after = [ routes.after ].filter(Boolean);\n    next.matched = true;\n    next.captures = [];\n    return filterRoutes(next);\n  }\n  for (var r in routes) {\n    if (routes.hasOwnProperty(r) && (!this._methods[r] || this._methods[r] && typeof routes[r] === \"object\" && !Array.isArray(routes[r]))) {\n      current = exact = regexp + this.delimiter + r;\n      if (!this.strict) {\n        exact += \"[\" + this.delimiter + \"]?\";\n      }\n      match = path.match(new RegExp(\"^\" + exact));\n      if (!match) {\n        continue;\n      }\n      if (match[0] && match[0] == path && routes[r][method]) {\n        next = [ [ routes[r].before, routes[r][method] ].filter(Boolean) ];\n        next.after = [ routes[r].after ].filter(Boolean);\n        next.matched = true;\n        next.captures = match.slice(1);\n        if (this.recurse && routes === this.routes) {\n          next.push([ routes.before, routes.on ].filter(Boolean));\n          next.after = next.after.concat([ routes.after ].filter(Boolean));\n        }\n        return filterRoutes(next);\n      }\n      next = this.traverse(method, path, routes[r], current);\n      if (next.matched) {\n        if (next.length > 0) {\n          fns = fns.concat(next);\n        }\n        if (this.recurse) {\n          fns.push([ routes[r].before, routes[r].on ].filter(Boolean));\n          next.after = next.after.concat([ routes[r].after ].filter(Boolean));\n          if (routes === this.routes) {\n            fns.push([ routes[\"before\"], routes[\"on\"] ].filter(Boolean));\n            next.after = next.after.concat([ routes[\"after\"] ].filter(Boolean));\n          }\n        }\n        fns.matched = true;\n        fns.captures = next.captures;\n        fns.after = next.after;\n        return filterRoutes(fns);\n      }\n    }\n  }\n  return false;\n};\n\nRouter.prototype.insert = function(method, path, route, parent) {\n  var methodType, parentType, isArray, nested, part;\n  path = path.filter(function(p) {\n    return p && p.length > 0;\n  });\n  parent = parent || this.routes;\n  part = path.shift();\n  if (/\\:|\\*/.test(part) && !/\\\\d|\\\\w/.test(part)) {\n    part = regifyString(part, this.params);\n  }\n  if (path.length > 0) {\n    parent[part] = parent[part] || {};\n    return this.insert(method, path, route, parent[part]);\n  }\n  if (!part && !path.length && parent === this.routes) {\n    methodType = typeof parent[method];\n    switch (methodType) {\n     case \"function\":\n      parent[method] = [ parent[method], route ];\n      return;\n     case \"object\":\n      parent[method].push(route);\n      return;\n     case \"undefined\":\n      parent[method] = route;\n      return;\n    }\n    return;\n  }\n  parentType = typeof parent[part];\n  isArray = Array.isArray(parent[part]);\n  if (parent[part] && !isArray && parentType == \"object\") {\n    methodType = typeof parent[part][method];\n    switch (methodType) {\n     case \"function\":\n      parent[part][method] = [ parent[part][method], route ];\n      return;\n     case \"object\":\n      parent[part][method].push(route);\n      return;\n     case \"undefined\":\n      parent[part][method] = route;\n      return;\n    }\n  } else if (parentType == \"undefined\") {\n    nested = {};\n    nested[method] = route;\n    parent[part] = nested;\n    return;\n  }\n  throw new Error(\"Invalid route context: \" + parentType);\n};\n\n\n\nRouter.prototype.extend = function(methods) {\n  var self = this, len = methods.length, i;\n  function extend(method) {\n    self._methods[method] = true;\n    self[method] = function() {\n      var extra = arguments.length === 1 ? [ method, \"\" ] : [ method ];\n      self.on.apply(self, extra.concat(Array.prototype.slice.call(arguments)));\n    };\n  }\n  for (i = 0; i < len; i++) {\n    extend(methods[i]);\n  }\n};\n\nRouter.prototype.runlist = function(fns) {\n  var runlist = this.every && this.every.before ? [ this.every.before ].concat(_flatten(fns)) : _flatten(fns);\n  if (this.every && this.every.on) {\n    runlist.push(this.every.on);\n  }\n  runlist.captures = fns.captures;\n  runlist.source = fns.source;\n  return runlist;\n};\n\nRouter.prototype.mount = function(routes, path) {\n  if (!routes || typeof routes !== \"object\" || Array.isArray(routes)) {\n    return;\n  }\n  var self = this;\n  path = path || [];\n  if (!Array.isArray(path)) {\n    path = path.split(self.delimiter);\n  }\n  function insertOrMount(route, local) {\n    var rename = route, parts = route.split(self.delimiter), routeType = typeof routes[route], isRoute = parts[0] === \"\" || !self._methods[parts[0]], event = isRoute ? \"on\" : rename;\n    if (isRoute) {\n      rename = rename.slice((rename.match(new RegExp(\"^\" + self.delimiter)) || [ \"\" ])[0].length);\n      parts.shift();\n    }\n    if (isRoute && routeType === \"object\" && !Array.isArray(routes[route])) {\n      local = local.concat(parts);\n      self.mount(routes[route], local);\n      return;\n    }\n    if (isRoute) {\n      local = local.concat(rename.split(self.delimiter));\n      local = terminator(local, self.delimiter);\n    }\n    self.insert(event, local, routes[route]);\n  }\n  for (var route in routes) {\n    if (routes.hasOwnProperty(route)) {\n      insertOrMount(route, path.slice(0));\n    }\n  }\n};\n\n\n\n}(typeof exports === \"object\" ? exports : window));","module.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n"]}