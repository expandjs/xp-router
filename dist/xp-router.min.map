{"version":3,"sources":["../../../../usr/lib/node_modules/browserify/node_modules/browser-pack/_prelude.js","index","lib/index.js","node_modules/director/build/director.js","node_modules/path-to-regexp/index.js","node_modules/isarray/index.js"],"names":["global","parser","require","XP","director","isBrowser","Router","http","module","exports","XPRouter","Class","initialize","server","self","this","_adaptee","_server","configure","recurse","on","_handleRequest","bind","path","method","callback","isFunction","assertArgument","isString","keys","running","pluck","toLowerCase","zipObject","arguments","assign","req","params","res","run","delay","init","route","get","getRoute","set","val","enumerable","validate","isObject","isDefined","chunks","chunk","push","body","join","dispatch","writeHead","end","window","dlocHashEmpty","dloc","hash","_every","arr","iterator","i","length","_flatten","flat","n","concat","_asyncEverySeries","completed","iterate","err","paramifyString","str","mod","param","hasOwnProperty","regifyString","matches","last","out","substr","match","index","replace","capture","captures","slice","terminator","routes","delimiter","start","stop","left","right","toString","indexOf","tmp","document","location","listener","mode","history","check","h","onHashChanged","fire","onpopstate","onhashchange","fn","onchange","onChangeEvent","l","listeners","undefined","documentMode","setTimeout","frame","createElement","id","style","display","appendChild","writeFrame","attachEvent","event","propertyName","setInterval","destroy","splice","setHash","s","pushState","title","f","getElementById","d","contentDocument","contentWindow","open","write","close","syncHash","_hash","methods","scope","_methods","_insert","insert","insertEx","historySupport","mount","prototype","r","routeTo","handler","newURL","url","getPath","charAt","convert_hash_in_init","replaceState","run_in_init","explode","v","split","setRoute","parent","once","apply","ret","pathname","QUERY_SEPARATOR","options","async","strict","notfound","resource","html5history","run_handler_in_init","every","after","before","token","matcher","compiled","RegExp","source","Array","isArray","forEach","p","m","routesFn","call","updateAndInvoke","fns","invoke","runlist","traverse","invoked","_invoked","reverse","thisArg","next","regexp","filter","filterRoutes","deepCopy","result","applyFilter","newRoutes","matched","current","exact","Boolean","methodType","parentType","nested","part","shift","test","Error","extend","extra","len","insertOrMount","local","rename","parts","routeType","isRoute","parse","tokens","key","PATH_REGEXP","exec","escaped","offset","prefix","name","group","suffix","asterisk","repeat","optional","pattern","escapeGroup","compile","tokensToFunction","obj","data","segment","value","TypeError","isarray","j","encodeURIComponent","escapeString","attachKeys","re","flags","sensitive","regexpToRegexp","groups","arrayToRegexp","pathToRegexp","stringToRegexp","tokensToRegExp","lastToken","endsWithSlash","Object"],"mappings":"AAAA;ACAA;;;CCSC,SAAUA,GACP,YAGA,IAAIC,GAAWC,QAAQ,kBACnBC,EAAWH,EAAOG,IAAMD,QAAQ,YAChCE,EAAWD,EAAGE,YAAcH,QAAQ,2BAA6BA,QAAQ,YACzEI,EAAWH,EAAGE,YAAcD,EAASE,OAASF,EAASG,KAAKD,MAUhEE,QAAOC,QAAUT,EAAOU,SAAW,GAAIP,GAAGQ,MAAM,YAM5CC,WAAY,SAAUC,GAGlB,GAAIC,GAAOC,IAGXD,GAAKE,SAAW,GAAIV,GACpBQ,EAAKG,QAAWd,EAAGE,YAAc,KAAOQ,EAGxCC,EAAKE,SAASE,WAAWC,SAAS,IAG9BL,EAAKG,SAAWH,EAAKG,QAAQG,GAAG,UAAWN,EAAKO,eAAeC,KAAKR,KAc5EM,GAAI,SAAUG,EAAMC,EAAQC,GAGpBtB,EAAGuB,WAAWF,KAAWC,EAAWD,EAAQA,EAAS,OAGzDrB,EAAGwB,eAAexB,EAAGyB,SAASL,GAAM,GAAO,EAAG,UAC9CpB,EAAGwB,eAAexB,EAAGyB,SAASJ,GAAQ,GAAO,EAAG,UAChDrB,EAAGwB,eAAexB,EAAGuB,WAAWD,GAAW,EAAG,WAG9C,IAAIX,GAAOC,KACPc,IAGJ,OAAIf,GAAKgB,QAAkBhB,GAG3Be,EAAS1B,EAAG4B,MAAM9B,EAAOsB,EAAMM,IAASA,EAAM,QAC9CL,EAASrB,EAAGE,YAAc,KAAOmB,EAAOQ,cAGpC7B,EAAGE,YACHS,EAAKE,SAASQ,GAAQD,EAAM,WAAcE,EAAStB,EAAG8B,UAAUJ,EAAMK,cAEtEpB,EAAKE,SAASQ,GAAQD,EAAM,WAAcE,EAAStB,EAAGgC,OAAOpB,KAAKqB,KAAMC,OAAQlC,EAAG8B,UAAUJ,EAAMK,aAAcnB,KAAKuB,OAGnHxB,IASXyB,IAAK,WAGD,GAAIzB,GAAOC,IAMX,QAHKD,EAAKgB,SAAW3B,EAAGE,aAAeF,EAAGqC,MAAM,WAAc1B,EAAKE,SAASyB,KAAK,OAG1E3B,GAYX4B,OACIC,IAAK,WAAc,MAAQ5B,MAAKe,SAAWf,KAAKC,SAAS4B,YAAe,OAU5Ed,SACIe,IAAK,SAAUC,GAAO,MAAO/B,MAAKe,WAAagB,IAYnD9B,UACI+B,YAAY,EACZF,IAAK,SAAUC,GAAO,MAAO/B,MAAKC,UAAY8B,GAC9CE,SAAU,SAAUF,GAAO,OAAQ3C,EAAG8C,SAASH,IAAQ,WAU3D7B,SACI8B,YAAY,EACZF,IAAK,SAAUC,GAAO,MAAO3C,GAAG+C,UAAUnC,KAAKE,SAAWF,KAAKE,QAAU6B,GACzEE,SAAU,SAAUF,GAAO,OAAQ3C,EAAGE,cAAgBF,EAAG8C,SAASH,IAAQ,WAM9EzB,eAAgB,SAAUe,EAAKE,GAG3B,GAAIxB,GAASC,KACToC,IAGJf,GAAIhB,GAAG,OAAQ,SAAUgC,GAASD,EAAOE,KAAKD,KAC9ChB,EAAIhB,GAAG,MAAO,WAAcgB,EAAIkB,KAAOnD,EAAGoD,KAAKJ,KAG/CrC,EAAKE,SAASwC,SAASpB,EAAKE,EAAK,WAC7BA,EAAImB,UAAU,KACdnB,EAAIoB,YAKA,mBAAXC,QAAyBA,OAAS3D;;;;CC9K1C,SAAUS,GAYX,QAASmD,KAGP,MAAqB,KAAdC,EAAKC,MAA6B,MAAdD,EAAKC,KAiRlC,QAASC,GAAOC,EAAKC,GACnB,IAAK,GAAIC,GAAI,EAAGA,EAAIF,EAAIG,OAAQD,GAAK,EACnC,GAAID,EAASD,EAAIE,GAAIA,EAAGF,MAAS,EAC/B,OAKN,QAASI,GAASJ,GAEhB,IAAK,GADDK,MACKH,EAAI,EAAGI,EAAIN,EAAIG,OAAYG,EAAJJ,EAAOA,IACrCG,EAAOA,EAAKE,OAAOP,EAAIE,GAEzB,OAAOG,GAGT,QAASG,GAAkBR,EAAKC,EAAUxC,GACxC,IAAKuC,EAAIG,OACP,MAAO1C,IAET,IAAIgD,GAAY,GAChB,QAAUC,KACRT,EAASD,EAAIS,GAAY,SAASE,GAC5BA,GAAOA,KAAQ,GACjBlD,EAASkD,GACTlD,EAAW,eAEXgD,GAAa,EACTA,IAAcT,EAAIG,OACpB1C,IAEAiD,UAOV,QAASE,GAAeC,EAAKxC,EAAQyC,GACnCA,EAAMD,CACN,KAAK,GAAIE,KAAS1C,GAChB,GAAIA,EAAO2C,eAAeD,KACxBD,EAAMzC,EAAO0C,GAAOF,GAChBC,IAAQD,GACV,KAIN,OAAOC,KAAQD,EAAM,uBAAyBC,EAGhD,QAASG,GAAaJ,EAAKxC,GAEzB,IADA,GAAI6C,GAASC,EAAO,EAAGC,EAAM,GACtBF,EAAUL,EAAIQ,OAAOF,GAAMG,MAAM,mCACtCH,EAAOD,EAAQK,MAAQL,EAAQ,GAAGf,OAClCe,EAAQ,GAAKA,EAAQ,GAAGM,QAAQ,MAAO,8BACvCJ,GAAOP,EAAIQ,OAAO,EAAGH,EAAQK,OAASL,EAAQ,EAEhDL,GAAMO,GAAOP,EAAIQ,OAAOF,EACxB,IAAyCM,GAAStB,EAA9CuB,EAAWb,EAAIS,MAAM,cACzB,IAAII,EAAU,CACZvB,EAASuB,EAASvB,MAClB,KAAK,GAAID,GAAI,EAAOC,EAAJD,EAAYA,IAC1BuB,EAAUC,EAASxB,GAEjBW,EAD0B,OAAxBY,EAAQE,MAAM,EAAG,GACbF,EAAQE,MAAM,GAEdd,EAAIW,QAAQC,EAASb,EAAea,EAASpD,IAIzD,MAAOwC,GAGT,QAASe,GAAWC,EAAQC,EAAWC,EAAOC,GAC5C,GAAuG9B,GAAnGiB,EAAO,EAAGc,EAAO,EAAGC,EAAQ,EAAGH,GAASA,GAAS,KAAKI,WAAYH,GAAQA,GAAQ,KAAKG,UAC3F,KAAKjC,EAAI,EAAGA,EAAI2B,EAAO1B,OAAQD,IAAK,CAClC,GAAId,GAAQyC,EAAO3B,EACnB,IAAId,EAAMgD,QAAQL,EAAOZ,GAAQ/B,EAAMgD,QAAQJ,EAAMb,KAAU/B,EAAMgD,QAAQL,EAAOZ,MAAW/B,EAAMgD,QAAQJ,EAAMb,MAAW/B,EAAMgD,QAAQL,EAAOZ,KAAU/B,EAAMgD,QAAQJ,EAAMb,GAAO,CAGtL,GAFAc,EAAO7C,EAAMgD,QAAQL,EAAOZ,GAC5Be,EAAQ9C,EAAMgD,QAAQJ,EAAMb,IACvBc,KAAUC,KAAWD,IAASC,EAAO,CACxC,GAAIG,GAAMR,EAAOF,MAAM,GAAIzB,GAAK,GAAK,GAAGX,KAAKuC,EAC7CD,IAAWQ,GAAM9B,OAAOsB,EAAOF,OAAOzB,GAAK,GAAK,IAElDiB,GAAQe,EAAQD,EAAOC,EAAQD,GAAQ,EACvC/B,EAAI,MAEJiB,GAAO,EAGX,MAAOU,GAjXT,GAAIhC,GAAOyC,SAASC,SAQhBC,GACFC,KAAM,SACN3C,KAAMD,EAAKC,KACX4C,SAAS,EAETC,MAAO,WACL,GAAIC,GAAI/C,EAAKC,IACT8C,IAAK7F,KAAK+C,OACZ/C,KAAK+C,KAAO8C,EACZ7F,KAAK8F,kBAITC,KAAM,WACc,WAAd/F,KAAK0F,KACP1F,KAAK2F,WAAY,EAAO/C,OAAOoD,aAAepD,OAAOqD,eAGrDjG,KAAK8F,iBAITpE,KAAM,SAAUwE,EAAIP,GAQlB,QAASQ,GAASC,GAChB,IAAK,GAAIjD,GAAI,EAAGkD,EAAI9G,EAAO+G,UAAUlD,OAAYiD,EAAJlD,EAAOA,IAClD5D,EAAO+G,UAAUnD,GAAGiD,GATxB,GAAIrG,GAAOC,IAcX,IAbAA,KAAK2F,QAAUA,EAEVpG,EAAO+G,YACV/G,EAAO+G,cAUL,gBAAkB1D,UAAqC2D,SAA1BhB,SAASiB,cACrCjB,SAASiB,aAAe,GAEvBxG,KAAK2F,WAAY,EAMnBc,WAAW,WACT7D,OAAOoD,WAAaG,GACnB,KAGHvD,OAAOqD,aAAeE,EAExBnG,KAAK0F,KAAO,aAET,CAIH,GAAIgB,GAAQnB,SAASoB,cAAc,SACnCD,GAAME,GAAK,cACXF,EAAMG,MAAMC,QAAU,OACtBvB,SAAShD,KAAKwE,YAAYL,GAC1B1G,KAAKgH,WAAW,IAEZ,oBAAsBzB,WAAY,eAAiBA,WACrDA,SAAS0B,YAAY,mBAAoB,WACZ,aAAvBC,MAAMC,cACRpH,EAAK6F,UAKXhD,OAAOwE,YAAY,WAAcrH,EAAK6F,SAAY,IAElD5F,KAAK8F,cAAgBK,EACrBnG,KAAK0F,KAAO,SAKd,MAFAnG,GAAO+G,UAAUhE,KAAK4D,GAEflG,KAAK0F,MAGd2B,QAAS,SAAUnB,GACjB,GAAK3G,GAAWA,EAAO+G,UAMvB,IAAK,GAFDA,GAAY/G,EAAO+G,UAEdnD,EAAImD,EAAUlD,OAAS,EAAGD,GAAK,EAAGA,IACrCmD,EAAUnD,KAAO+C,GACnBI,EAAUgB,OAAOnE,EAAG,IAK1BoE,QAAS,SAAUC,GAcjB,MAZkB,WAAdxH,KAAK0F,MACP1F,KAAKgH,WAAWQ,GAGdxH,KAAK2F,WAAY,GACnB/C,OAAO+C,QAAQ8B,aAAclC,SAASmC,MAAOF,GAG7CxH,KAAK+F,QAELjD,EAAKC,KAAiB,MAATyE,EAAE,GAAcA,EAAI,IAAMA,EAElCxH,MAGTgH,WAAY,SAAUQ,GAEpB,GAAIG,GAAIpC,SAASqC,eAAe,eAC5BC,EAAIF,EAAEG,iBAAmBH,EAAEI,cAAcxC,QAC7CsC,GAAEG,OACFH,EAAEI,MAAM,oBAAsBT,EAAI,iDAClCK,EAAEK,SAGJC,SAAU,WAER,GAAIX,GAAIxH,KAAKoI,KAIb,OAHIZ,IAAK1E,EAAKC,OACZD,EAAKC,KAAOyE,GAEPxH,MAGT8F,cAAe,cAGbvG,EAASG,EAAQH,OAAS,SAAUuF,GACtC,MAAM9E,gBAAgBT,IAEtBS,KAAKsB,UACLtB,KAAK8E,UACL9E,KAAKqI,SAAY,KAAM,OAAQ,QAAS,UACxCrI,KAAKsI,SACLtI,KAAKuI,YAELvI,KAAKwI,QAAUxI,KAAKyI,OACpBzI,KAAKyI,OAASzI,KAAK0I,SAEnB1I,KAAK2I,eAA+E,OAA3C,MAAlB/F,OAAO+C,QAAkB/C,OAAO+C,QAAQ8B,UAAY,MAE3EzH,KAAKG,gBACLH,MAAK4I,MAAM9D,QAd2B,GAAIvF,GAAOuF,GAiBnDvF,GAAOsJ,UAAUnH,KAAO,SAAUoH,GAChC,GACIC,GADAhJ,EAAOC,IAqCX,OAnCAA,MAAKgJ,QAAU,SAAS5C,GACtB,GAAI6C,GAAS7C,GAAiBA,EAAc6C,QAAUrG,OAAO4C,SAASzC,KAClEmG,EAAMnJ,EAAK4F,WAAY,EAAO5F,EAAKoJ,UAAYF,EAAOxE,QAAQ,MAAO,GACzE1E,GAAK0C,SAAS,KAAwB,MAAlByG,EAAIE,OAAO,GAAaF,EAAM,IAAMA,IAG1DzD,EAAS/D,KAAK1B,KAAKgJ,QAAShJ,KAAK2F,SAE7B3F,KAAK2F,WAAY,EACf9C,KAAmBiG,EACrBhG,EAAKC,KAAO+F,EACFjG,KACV9C,EAAK0C,SAAS,KAAM,IAAMK,EAAKC,KAAK0B,QAAQ,cAAe,MAIzDzE,KAAKqJ,sBAEPN,EAAUlG,KAAmBiG,EAAIA,EAAKjG,IAAgD,KAA9BC,EAAKC,KAAK0B,QAAQ,KAAM,IAC5EsE,GACFnG,OAAO+C,QAAQ2D,gBAAiB/D,SAASmC,MAAOqB,IAKlDA,EAAU/I,KAAKmJ,WAKbJ,GAAW/I,KAAKuJ,eAAgB,IAClCvJ,KAAKgJ,WAIFhJ,MAGTT,EAAOsJ,UAAUW,QAAU,WACzB,GAAIC,GAAIzJ,KAAK2F,WAAY,EAAO3F,KAAKmJ,UAAYrG,EAAKC,IAEtD,OADoB,MAAhB0G,EAAEL,OAAO,KAAcK,EAAEA,EAAE7E,MAAM,IAC9B6E,EAAE7E,MAAM,EAAG6E,EAAErG,QAAQsG,MAAM,MAGpCnK,EAAOsJ,UAAUc,SAAW,SAAUxG,EAAGsG,EAAG1H,GAC1C,GAAImH,GAAMlJ,KAAKwJ,SAaf,OAXiB,gBAANrG,IAA+B,gBAANsG,GAClCP,EAAI/F,GAAKsG,EAEa,gBAAR1H,GACdmH,EAAI5B,OAAOnE,EAAGsG,EAAGjC,GAGjB0B,GAAO/F,GAGTsC,EAAS8B,QAAQ2B,EAAI1G,KAAK,MACnB0G,GAWT3J,EAAOsJ,UAAUH,SAAW,SAASjI,EAAQD,EAAMmB,EAAOiI,GAYxD,MAXe,SAAXnJ,IACFA,EAAS,KACTkB,EAAQ,SAASA,GACf,GAAIkI,IAAO,CACX,OAAO,YACL,MAAIA,GAAJ,QACAA,GAAO,EACAlI,EAAMmI,MAAM9J,KAAMmB,cAE3BQ,IAEG3B,KAAKwI,QAAQ/H,EAAQD,EAAMmB,EAAOiI,IAG3CrK,EAAOsJ,UAAUhH,SAAW,SAAU4H,GACpC,GAAIM,GAAMN,CAEV,IAAiB,gBAANA,GACTM,EAAM/J,KAAKwJ,UAAUC,OAElB,IAAiB,gBAANA,GAAe,CAC7B,GAAI5D,GAAI7F,KAAKwJ,SACbO,GAAMlE,EAAER,QAAQoE,OAGhBM,GAAM/J,KAAKwJ,SAGb,OAAOO,IAGTxK,EAAOsJ,UAAUxB,QAAU,WAEzB,MADA5B,GAAS4B,QAAQrH,KAAKgJ,SACfhJ,MAGTT,EAAOsJ,UAAUM,QAAU,WACzB,GAAI3I,GAAOoC,OAAO4C,SAASwE,QAI3B,OAH0B,MAAtBxJ,EAAK8D,OAAO,EAAG,KACjB9D,EAAO,IAAMA,GAERA,EAgGT,IAAIyJ,GAAkB,MAEtB1K,GAAOsJ,UAAU1I,UAAY,SAAS+J,GACpCA,EAAUA,KACV,KAAK,GAAI/G,GAAI,EAAGA,EAAInD,KAAKqI,QAAQjF,OAAQD,IACvCnD,KAAKuI,SAASvI,KAAKqI,QAAQlF,KAAM,CAgBnC,OAdAnD,MAAKI,QAAU8J,EAAQ9J,SAAWJ,KAAKI,UAAW,EAClDJ,KAAKmK,MAAQD,EAAQC,QAAS,EAC9BnK,KAAK+E,UAAYmF,EAAQnF,WAAa,IACtC/E,KAAKoK,OAAmC,mBAAnBF,GAAQE,QAAyB,EAAOF,EAAQE,OACrEpK,KAAKqK,SAAWH,EAAQG,SACxBrK,KAAKsK,SAAWJ,EAAQI,SACxBtK,KAAK2F,QAAUuE,EAAQK,cAAgBvK,KAAK2I,iBAAkB,EAC9D3I,KAAKuJ,YAAcvJ,KAAK2F,WAAY,GAAQuE,EAAQM,uBAAwB,EAC5ExK,KAAKqJ,qBAAuBrJ,KAAK2F,WAAY,GAAQuE,EAAQb,wBAAyB,EACtFrJ,KAAKyK,OACHC,MAAOR,EAAQQ,OAAS,KACxBC,OAAQT,EAAQS,QAAU,KAC1BtK,GAAI6J,EAAQ7J,IAAM,MAEbL,MAGTT,EAAOsJ,UAAU7E,MAAQ,SAAS4G,EAAOC,GACtB,MAAbD,EAAM,KACRA,EAAQ,IAAMA,EAEhB,IAAIE,GAAW,GAAIC,QAAOH,EAAO,IAIjC,OAHA5K,MAAKsB,OAAOsJ,GAAS,SAAS9G,GAC5B,MAAOA,GAAIW,QAAQqG,EAAUD,EAAQG,QAAUH,IAE1C7K,MAGTT,EAAOsJ,UAAUxI,GAAKd,EAAOsJ,UAAUlH,MAAQ,SAASlB,EAAQD,EAAMmB,GACpE,GAAI5B,GAAOC,IAMX,OALK2B,IAAwB,kBAARnB,KACnBmB,EAAQnB,EACRA,EAAOC,EACPA,EAAS,MAEPwK,MAAMC,QAAQ1K,GACTA,EAAK2K,QAAQ,SAASC,GAC3BrL,EAAKM,GAAGI,EAAQ2K,EAAGzJ,MAGnBnB,EAAKwK,SACPxK,EAAOA,EAAKwK,OAAOvG,QAAQ,SAAU,MAEnCwG,MAAMC,QAAQzK,GACTA,EAAO0K,QAAQ,SAASE,GAC7BtL,EAAKM,GAAGgL,EAAEpK,cAAeT,EAAMmB,MAGnCnB,EAAOA,EAAKkJ,MAAM,GAAIqB,QAAO/K,KAAK+E,YAClCvE,EAAOqE,EAAWrE,EAAMR,KAAK+E,eAC7B/E,MAAKyI,OAAOhI,EAAQT,KAAKsI,MAAM9E,OAAOhD,GAAOmB,MAG/CpC,EAAOsJ,UAAUrI,KAAO,SAASA,EAAM8K,GACrC,GAAiBlI,GAASpD,KAAKsI,MAAMlF,MACjC5C,GAAKwK,SACPxK,EAAOA,EAAKwK,OAAOvG,QAAQ,SAAU,MAEvCjE,EAAOA,EAAKkJ,MAAM,GAAIqB,QAAO/K,KAAK+E,YAClCvE,EAAOqE,EAAWrE,EAAMR,KAAK+E,WAC7B/E,KAAKsI,MAAQtI,KAAKsI,MAAM9E,OAAOhD,GAC/B8K,EAASC,KAAKvL,KAAMA,MACpBA,KAAKsI,MAAMhB,OAAOlE,EAAQ5C,EAAK4C,SAGjC7D,EAAOsJ,UAAUpG,SAAW,SAAShC,EAAQD,EAAME,GAgBjD,QAAS8K,KACPzL,EAAKqE,KAAOqH,EAAIf,MAChB3K,EAAK2L,OAAO3L,EAAK4L,QAAQF,GAAM1L,EAAMW,GAjBvC,GAA2HgK,GAAvH3K,EAAOC,KAAMyL,EAAMzL,KAAK4L,SAASnL,EAAQD,EAAKiE,QAAQwF,EAAiB,IAAKjK,KAAK8E,OAAQ,IAAK+G,EAAU7L,KAAK8L,QAEjH,OADA9L,MAAK8L,UAAW,EACXL,GAAsB,IAAfA,EAAIrI,QAUK,YAAjBpD,KAAKI,UACPqL,EAAMA,EAAIM,WAMZrB,EAAQ1K,KAAKyK,OAASzK,KAAKyK,MAAMC,OAAU1K,KAAKyK,MAAMC,OAAQlH,OAAOxD,KAAKoE,OAAUpE,KAAKoE,MACrFsG,GAASA,EAAMtH,OAAS,GAAKyI,GAC3B7L,KAAKmK,MACPnK,KAAK0L,OAAOhB,EAAO1K,KAAMwL,IAEzBxL,KAAK0L,OAAOhB,EAAO1K,MACnBwL,MAEK,IAETA,KACO,KA3BLxL,KAAKoE,QACwB,kBAAlBpE,MAAKqK,UACdrK,KAAK0L,QAAS1L,KAAKqK,WACjB5J,OAAQA,EACRD,KAAMA,GACLE,IAEE,IAuBXnB,EAAOsJ,UAAU6C,OAAS,SAASD,EAAKO,EAAStL,GAC/C,GACIoJ,GADA/J,EAAOC,IAEPA,MAAKmK,OACPL,EAAQ,SAAS5D,EAAI+F,GACnB,MAAIhB,OAAMC,QAAQhF,GACTzC,EAAkByC,EAAI4D,EAAOmC,QACd,kBAAN/F,IAChBA,EAAG4D,MAAMkC,GAAUP,EAAI9G,cAAgBnB,OAAOyI,MAGlDxI,EAAkBgI,EAAK3B,EAAO,WACxBpJ,GACFA,EAASoJ,MAAMkC,EAAS7K,eAI5B2I,EAAQ,SAAS5D,GACf,MAAI+E,OAAMC,QAAQhF,GACTlD,EAAOkD,EAAI4D,GACK,kBAAP5D,GACTA,EAAG4D,MAAMkC,EAASP,EAAI9G,mBACN,gBAAPuB,IAAmBnG,EAAKuK,UACxCvK,EAAKuK,SAASpE,GAAI4D,MAAMkC,EAASP,EAAI9G,gBAGzC3B,EAAOyI,EAAK3B,KAIhBvK,EAAOsJ,UAAU+C,SAAW,SAASnL,EAAQD,EAAMsE,EAAQoH,EAAQC,GAEjE,QAASC,GAAatH,GAIpB,QAASuH,GAASrB,GAEhB,IAAK,GADDsB,MACKnJ,EAAI,EAAGA,EAAI6H,EAAO5H,OAAQD,IACjCmJ,EAAOnJ,GAAK8H,MAAMC,QAAQF,EAAO7H,IAAMkJ,EAASrB,EAAO7H,IAAM6H,EAAO7H,EAEtE,OAAOmJ,GAET,QAASC,GAAYd,GACnB,IAAK,GAAItI,GAAIsI,EAAIrI,OAAS,EAAGD,GAAK,EAAGA,IAC/B8H,MAAMC,QAAQO,EAAItI,KACpBoJ,EAAYd,EAAItI,IACM,IAAlBsI,EAAItI,GAAGC,QACTqI,EAAInE,OAAOnE,EAAG,IAGXgJ,EAAOV,EAAItI,KACdsI,EAAInE,OAAOnE,EAAG,GAnBtB,IAAKgJ,EACH,MAAOrH,EAuBT,IAAI0H,GAAYH,EAASvH,EAKzB,OAJA0H,GAAUC,QAAU3H,EAAO2H,QAC3BD,EAAU7H,SAAWG,EAAOH,SAC5B6H,EAAU9B,MAAQ5F,EAAO4F,MAAMyB,OAAOA,GACtCI,EAAYC,GACLA,EA/BT,GAAcE,GAASC,EAAOpI,EAAO0H,EAAjCR,IAiCJ,IAAIjL,IAASR,KAAK+E,WAAaD,EAAOrE,GAKpC,MAJAwL,KAAWnH,EAAO6F,OAAQ7F,EAAOrE,IAAU0L,OAAOS,UAClDX,EAAKvB,OAAU5F,EAAO4F,OAAQyB,OAAOS,SACrCX,EAAKQ,SAAU,EACfR,EAAKtH,YACEyH,EAAaH,EAEtB,KAAK,GAAInD,KAAKhE,GACZ,GAAIA,EAAOb,eAAe6E,MAAQ9I,KAAKuI,SAASO,IAAM9I,KAAKuI,SAASO,IAA2B,gBAAdhE,GAAOgE,KAAoBmC,MAAMC,QAAQpG,EAAOgE,KAAM,CAMrI,GALA4D,EAAUC,EAAQT,EAASlM,KAAK+E,UAAY+D,EACvC9I,KAAKoK,SACRuC,GAAS,IAAM3M,KAAK+E,UAAY,MAElCR,EAAQ/D,EAAK+D,MAAM,GAAIwG,QAAO,IAAM4B,KAC/BpI,EACH,QAEF,IAAIA,EAAM,IAAMA,EAAM,IAAM/D,GAAQsE,EAAOgE,GAAGrI,GAS5C,MARAwL,KAAWnH,EAAOgE,GAAG6B,OAAQ7F,EAAOgE,GAAGrI,IAAU0L,OAAOS,UACxDX,EAAKvB,OAAU5F,EAAOgE,GAAG4B,OAAQyB,OAAOS,SACxCX,EAAKQ,SAAU,EACfR,EAAKtH,SAAWJ,EAAMK,MAAM,GACxB5E,KAAKI,SAAW0E,IAAW9E,KAAK8E,SAClCmH,EAAK3J,MAAOwC,EAAO6F,OAAQ7F,EAAOzE,IAAK8L,OAAOS,UAC9CX,EAAKvB,MAAQuB,EAAKvB,MAAMlH,QAASsB,EAAO4F,OAAQyB,OAAOS,WAElDR,EAAaH,EAGtB,IADAA,EAAOjM,KAAK4L,SAASnL,EAAQD,EAAMsE,EAAOgE,GAAI4D,GAC1CT,EAAKQ,QAeP,MAdIR,GAAK7I,OAAS,IAChBqI,EAAMA,EAAIjI,OAAOyI,IAEfjM,KAAKI,UACPqL,EAAInJ,MAAOwC,EAAOgE,GAAG6B,OAAQ7F,EAAOgE,GAAGzI,IAAK8L,OAAOS,UACnDX,EAAKvB,MAAQuB,EAAKvB,MAAMlH,QAASsB,EAAOgE,GAAG4B,OAAQyB,OAAOS,UACtD9H,IAAW9E,KAAK8E,SAClB2G,EAAInJ,MAAOwC,EAAe,OAAGA,EAAW,IAAIqH,OAAOS,UACnDX,EAAKvB,MAAQuB,EAAKvB,MAAMlH,QAASsB,EAAc,OAAIqH,OAAOS,YAG9DnB,EAAIgB,SAAU,EACdhB,EAAI9G,SAAWsH,EAAKtH,SACpB8G,EAAIf,MAAQuB,EAAKvB,MACV0B,EAAaX,GAI1B,OAAO,GAGTlM,EAAOsJ,UAAUJ,OAAS,SAAShI,EAAQD,EAAMmB,EAAOiI,GACtD,GAAIiD,GAAYC,EAAY5B,EAAS6B,EAAQC,CAS7C,IARAxM,EAAOA,EAAK2L,OAAO,SAASf,GAC1B,MAAOA,IAAKA,EAAEhI,OAAS,IAEzBwG,EAASA,GAAU5J,KAAK8E,OACxBkI,EAAOxM,EAAKyM,QACR,QAAQC,KAAKF,KAAU,UAAUE,KAAKF,KACxCA,EAAO9I,EAAa8I,EAAMhN,KAAKsB,SAE7Bd,EAAK4C,OAAS,EAEhB,MADAwG,GAAOoD,GAAQpD,EAAOoD,OACfhN,KAAKyI,OAAOhI,EAAQD,EAAMmB,EAAOiI,EAAOoD,GAEjD,IAAKA,GAASxM,EAAK4C,QAAUwG,IAAW5J,KAAK8E,OAA7C,CAiBA,GAFAgI,QAAoBlD,GAAOoD,GAC3B9B,EAAUD,MAAMC,QAAQtB,EAAOoD,IAC3BpD,EAAOoD,KAAU9B,GAAyB,UAAd4B,EAE9B,OADAD,QAAoBjD,GAAOoD,GAAMvM,IAEhC,IAAK,WAEJ,YADAmJ,EAAOoD,GAAMvM,IAAYmJ,EAAOoD,GAAMvM,GAASkB,GAEhD,KAAK,SAEJ,WADAiI,GAAOoD,GAAMvM,GAAQ6B,KAAKX,EAE3B,KAAK,YAEJ,YADAiI,EAAOoD,GAAMvM,GAAUkB,OAGpB,IAAkB,aAAdmL,EAIT,MAHAC,MACAA,EAAOtM,GAAUkB,OACjBiI,EAAOoD,GAAQD,EAGjB,MAAM,IAAII,OAAM,0BAA4BL,GAlC1C,OADAD,QAAoBjD,GAAOnJ,IAE1B,IAAK,WAEJ,YADAmJ,EAAOnJ,IAAYmJ,EAAOnJ,GAASkB,GAEpC,KAAK,SAEJ,WADAiI,GAAOnJ,GAAQ6B,KAAKX,EAErB,KAAK,YAEJ,YADAiI,EAAOnJ,GAAUkB,KA+BvBpC,EAAOsJ,UAAUuE,OAAS,SAAS/E,GAEjC,QAAS+E,GAAO3M,GACdV,EAAKwI,SAAS9H,IAAU,EACxBV,EAAKU,GAAU,WACb,GAAI4M,GAA6B,IAArBlM,UAAUiC,QAAiB3C,EAAQ,KAASA,EACxDV,GAAKM,GAAGyJ,MAAM/J,EAAMsN,EAAM7J,OAAOyH,MAAMpC,UAAUjE,MAAM2G,KAAKpK,cALhE,GAAuCgC,GAAnCpD,EAAOC,KAAMsN,EAAMjF,EAAQjF,MAQ/B,KAAKD,EAAI,EAAOmK,EAAJnK,EAASA,IACnBiK,EAAO/E,EAAQlF,KAInB5D,EAAOsJ,UAAU8C,QAAU,SAASF,GAClC,GAAIE,GAAU3L,KAAKyK,OAASzK,KAAKyK,MAAME,QAAW3K,KAAKyK,MAAME,QAASnH,OAAOH,EAASoI,IAAQpI,EAASoI,EAMvG,OALIzL,MAAKyK,OAASzK,KAAKyK,MAAMpK,IAC3BsL,EAAQrJ,KAAKtC,KAAKyK,MAAMpK,IAE1BsL,EAAQhH,SAAW8G,EAAI9G,SACvBgH,EAAQX,OAASS,EAAIT,OACdW,GAGTpM,EAAOsJ,UAAUD,MAAQ,SAAS9D,EAAQtE,GASxC,QAAS+M,GAAc5L,EAAO6L,GAC5B,GAAIC,GAAS9L,EAAO+L,EAAQ/L,EAAM+H,MAAM3J,EAAKgF,WAAY4I,QAAmB7I,GAAOnD,GAAQiM,EAAuB,KAAbF,EAAM,KAAc3N,EAAKwI,SAASmF,EAAM,IAAKxG,EAAQ0G,EAAU,KAAOH,CAK3K,OAJIG,KACFH,EAASA,EAAO7I,OAAO6I,EAAOlJ,MAAM,GAAIwG,QAAO,IAAMhL,EAAKgF,cAAiB,KAAM,GAAG3B,QACpFsK,EAAMT,SAEJW,GAAyB,WAAdD,IAA2B1C,MAAMC,QAAQpG,EAAOnD,KAC7D6L,EAAQA,EAAMhK,OAAOkK,OACrB3N,GAAK6I,MAAM9D,EAAOnD,GAAQ6L,KAGxBI,IACFJ,EAAQA,EAAMhK,OAAOiK,EAAO/D,MAAM3J,EAAKgF,YACvCyI,EAAQ3I,EAAW2I,EAAOzN,EAAKgF,gBAEjChF,GAAK0I,OAAOvB,EAAOsG,EAAO1I,EAAOnD,KAvBnC,GAAKmD,GAA4B,gBAAXA,KAAuBmG,MAAMC,QAAQpG,GAA3D,CAGA,GAAI/E,GAAOC,IACXQ,GAAOA,MACFyK,MAAMC,QAAQ1K,KACjBA,EAAOA,EAAKkJ,MAAM3J,EAAKgF,WAmBzB,KAAK,GAAIpD,KAASmD,GACZA,EAAOb,eAAetC,IACxB4L,EAAc5L,EAAOnB,EAAKoE,MAAM,OAOjB,gBAAZlF,SAAuBA,QAAUkD;;AEptB1CnD,OAAOC,QAAUuL,MAAMC,SAAW,SAAUjI,GAC1C,MAA8C,kBAAvCmN,OAAOvH,UAAUzD,SAASmG,KAAKtI;;ADkCxC,QAAS4K,OAAO/J,GAOd,IANA,GAIIvC,GAJAuM,KACAC,EAAM,EACNvJ,EAAQ,EACRhE,EAAO,GAG6B,OAAhCe,EAAMyM,YAAYC,KAAKnK,KAAe,CAC5C,GAAIuH,GAAI9J,EAAI,GACR2M,EAAU3M,EAAI,GACd4M,EAAS5M,EAAIiD,KAKjB,IAJAhE,GAAQsD,EAAIc,MAAMJ,EAAO2J,GACzB3J,EAAQ2J,EAAS9C,EAAEjI,OAGf8K,EACF1N,GAAQ0N,EAAQ,OADlB,CAMI1N,IACFsN,EAAOxL,KAAK9B,GACZA,EAAO,GAGT,IAAI4N,GAAS7M,EAAI,GACb8M,EAAO9M,EAAI,GACXmD,EAAUnD,EAAI,GACd+M,EAAQ/M,EAAI,GACZgN,EAAShN,EAAI,GACbiN,EAAWjN,EAAI,GAEfkN,EAAoB,MAAXF,GAA6B,MAAXA,EAC3BG,EAAsB,MAAXH,GAA6B,MAAXA,EAC7BxJ,EAAYqJ,GAAU,IACtBO,EAAUjK,GAAW4J,IAAUE,EAAW,KAAO,KAAOzJ,EAAY,MAExE+I,GAAOxL,MACL+L,KAAMA,GAAQN,IACdK,OAAQA,GAAU,GAClBrJ,UAAWA,EACX2J,SAAUA,EACVD,OAAQA,EACRE,QAASC,YAAYD,MAczB,MATInK,GAAQV,EAAIV,SACd5C,GAAQsD,EAAIQ,OAAOE,IAIjBhE,GACFsN,EAAOxL,KAAK9B,GAGPsN,EAST,QAASe,SAAS/K,GAChB,MAAOgL,kBAAiBjB,MAAM/J,IAMhC,QAASgL,kBAAkBhB,GAKzB,IAAK,GAHD3J,GAAU,GAAI8G,OAAM6C,EAAO1K,QAGtBD,EAAI,EAAGA,EAAI2K,EAAO1K,OAAQD,IACR,gBAAd2K,GAAO3K,KAChBgB,EAAQhB,GAAK,GAAI4H,QAAO,IAAM+C,EAAO3K,GAAGwL,QAAU,KAItD,OAAO,UAAUI,GAIf,IAAK,GAHDvO,GAAO,GACPwO,EAAOD,MAEF5L,EAAI,EAAGA,EAAI2K,EAAO1K,OAAQD,IAAK,CACtC,GAAIyH,GAAQkD,EAAO3K,EAEnB,IAAqB,gBAAVyH,GAAX,CAMA,GACIqE,GADAC,EAAQF,EAAKpE,EAAMyD,KAGvB,IAAa,MAATa,EAAe,CACjB,GAAItE,EAAM8D,SACR,QAEA,MAAM,IAAIS,WAAU,aAAevE,EAAMyD,KAAO,mBAIpD,GAAIe,QAAQF,GAAZ,CACE,IAAKtE,EAAM6D,OACT,KAAM,IAAIU,WAAU,aAAevE,EAAMyD,KAAO,kCAAoCa,EAAQ,IAG9F,IAAqB,IAAjBA,EAAM9L,OAAc,CACtB,GAAIwH,EAAM8D,SACR,QAEA,MAAM,IAAIS,WAAU,aAAevE,EAAMyD,KAAO,qBAIpD,IAAK,GAAIgB,GAAI,EAAGA,EAAIH,EAAM9L,OAAQiM,IAAK,CAGrC,GAFAJ,EAAUK,mBAAmBJ,EAAMG,KAE9BlL,EAAQhB,GAAG+J,KAAK+B,GACnB,KAAM,IAAIE,WAAU,iBAAmBvE,EAAMyD,KAAO,eAAiBzD,EAAM+D,QAAU,oBAAsBM,EAAU,IAGvHzO,KAAe,IAAN6O,EAAUzE,EAAMwD,OAASxD,EAAM7F,WAAakK,OApBzD,CA4BA,GAFAA,EAAUK,mBAAmBJ,IAExB/K,EAAQhB,GAAG+J,KAAK+B,GACnB,KAAM,IAAIE,WAAU,aAAevE,EAAMyD,KAAO,eAAiBzD,EAAM+D,QAAU,oBAAsBM,EAAU,IAGnHzO,IAAQoK,EAAMwD,OAASa,OAhDrBzO,IAAQoK,EAmDZ,MAAOpK,IAUX,QAAS+O,cAAczL,GACrB,MAAOA,GAAIW,QAAQ,2BAA4B,QASjD,QAASmK,aAAaN,GACpB,MAAOA,GAAM7J,QAAQ,gBAAiB,QAUxC,QAAS+K,YAAYC,EAAI3O,GAEvB,MADA2O,GAAG3O,KAAOA,EACH2O,EAST,QAASC,OAAOxF,GACd,MAAOA,GAAQyF,UAAY,GAAK,IAUlC,QAASC,gBAAgBpP,EAAMM,GAE7B,GAAI+O,GAASrP,EAAKwK,OAAOzG,MAAM,YAE/B,IAAIsL,EACF,IAAK,GAAI1M,GAAI,EAAGA,EAAI0M,EAAOzM,OAAQD,IACjCrC,EAAKwB,MACH+L,KAAMlL,EACNiL,OAAQ,KACRrJ,UAAW,KACX2J,UAAU,EACVD,QAAQ,EACRE,QAAS,MAKf,OAAOa,YAAWhP,EAAMM,GAW1B,QAASgP,eAAetP,EAAMM,EAAMoJ,GAGlC,IAAK,GAFDwD,MAEKvK,EAAI,EAAGA,EAAI3C,EAAK4C,OAAQD,IAC/BuK,EAAMpL,KAAKyN,aAAavP,EAAK2C,GAAIrC,EAAMoJ,GAASc,OAGlD,IAAIkB,GAAS,GAAInB,QAAO,MAAQ2C,EAAMlL,KAAK,KAAO,IAAKkN,MAAMxF,GAE7D,OAAOsF,YAAWtD,EAAQpL,GAW5B,QAASkP,gBAAgBxP,EAAMM,EAAMoJ,GAKnC,IAAK,GAJD4D,GAASD,MAAMrN,GACfiP,EAAKQ,eAAenC,EAAQ5D,GAGvB/G,EAAI,EAAGA,EAAI2K,EAAO1K,OAAQD,IACR,gBAAd2K,GAAO3K,IAChBrC,EAAKwB,KAAKwL,EAAO3K,GAIrB,OAAOqM,YAAWC,EAAI3O,GAWxB,QAASmP,gBAAgBnC,EAAQ5D,GAC/BA,EAAUA,KASV,KAAK,GAPDE,GAASF,EAAQE,OACjBzH,EAAMuH,EAAQvH,OAAQ,EACtBhB,EAAQ,GACRuO,EAAYpC,EAAOA,EAAO1K,OAAS,GACnC+M,EAAqC,gBAAdD,IAA0B,MAAMhD,KAAKgD,GAGvD/M,EAAI,EAAGA,EAAI2K,EAAO1K,OAAQD,IAAK,CACtC,GAAIyH,GAAQkD,EAAO3K,EAEnB,IAAqB,gBAAVyH,GACTjJ,GAAS4N,aAAa3E,OACjB,CACL,GAAIwD,GAASmB,aAAa3E,EAAMwD,QAC5B1J,EAAUkG,EAAM+D,OAEhB/D,GAAM6D,SACR/J,GAAW,MAAQ0J,EAAS1J,EAAU,MAKpCA,EAFAkG,EAAM8D,SACJN,EACQ,MAAQA,EAAS,IAAM1J,EAAU,MAEjC,IAAMA,EAAU,KAGlB0J,EAAS,IAAM1J,EAAU,IAGrC/C,GAAS+C,GAoBb,MAZK0F,KACHzI,GAASwO,EAAgBxO,EAAMiD,MAAM,EAAG,IAAMjD,GAAS,iBAIvDA,GADEgB,EACO,IAIAyH,GAAU+F,EAAgB,GAAK,YAGnC,GAAIpF,QAAO,IAAMpJ,EAAO+N,MAAMxF,IAevC,QAAS6F,cAAcvP,EAAMM,EAAMoJ,GAUjC,MATApJ,GAAOA,MAEFsO,QAAQtO,GAGDoJ,IACVA,OAHAA,EAAUpJ,EACVA,MAKEN,YAAgBuK,QACX6E,eAAepP,EAAMM,EAAMoJ,GAGhCkF,QAAQ5O,GACHsP,cAActP,EAAMM,EAAMoJ,GAG5B8F,eAAexP,EAAMM,EAAMoJ,GApYpC,GAAIkF,SAAUjQ,QAAQ,UAKtBM,QAAOC,QAAUqQ,aACjBtQ,OAAOC,QAAQmO,MAAQA,MACvBpO,OAAOC,QAAQmP,QAAUA,QACzBpP,OAAOC,QAAQoP,iBAAmBA,iBAClCrP,OAAOC,QAAQuQ,eAAiBA,cAOhC,IAAIjC,aAAc,GAAIjD,SAGpB,UAOA,kGACAvI,KAAK,KAAM","file":"bundle.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","module.exports=require(\"./lib\");","/*jslint browser: true, devel: true, node: true, ass: true, nomen: true, unparam: true, indent: 4 */\n\n/**\n * @license\n * Copyright (c) 2015 The ExpandJS authors. All rights reserved.\n * This code may only be used under the BSD style license found at https://expandjs.github.io/LICENSE.txt\n * The complete set of authors may be found at https://expandjs.github.io/AUTHORS.txt\n * The complete set of contributors may be found at https://expandjs.github.io/CONTRIBUTORS.txt\n */\n(function (global) {\n    \"use strict\";\n\n    // Vars\n    var parser   = require('path-to-regexp'),\n        XP       = global.XP || require('expandjs'),\n        director = XP.isBrowser() ? require('director/build/director') : require('director'),\n        Router   = XP.isBrowser() ? director.Router : director.http.Router;\n\n    /*********************************************************************/\n\n    /**\n     * A class used to perform client/server side routing.\n     *\n     * @class XPRouter\n     * @description A class used to perform client/server side routing\n     */\n    module.exports = global.XPRouter = new XP.Class('XPRouter', {\n\n        /**\n         * @constructs\n         * @param {Object} [server]\n         */\n        initialize: function (server) {\n\n            // Vars\n            var self = this;\n\n            // Setting\n            self._adaptee = new Router();\n            self._server  = XP.isBrowser() ? null : server;\n\n            // Configuring\n            self._adaptee.configure({recurse: false});\n\n            // Listening\n            if (self._server) { self._server.on('request', self._handleRequest.bind(self)); }\n        },\n\n        /*********************************************************************/\n\n        /**\n         * TODO DOC\n         *\n         * @method on\n         * @param {string} path\n         * @param {string} [method = \"GET\"]\n         * @param {Function} callback\n         * @returns {Object}\n         */\n        on: function (path, method, callback) {\n\n            // Preparing\n            if (XP.isFunction(method)) { callback = method; method = 'GET'; }\n\n            // Asserting\n            XP.assertArgument(XP.isString(path, true), 1, 'string');\n            XP.assertArgument(XP.isString(method, true), 2, 'string');\n            XP.assertArgument(XP.isFunction(callback), 3, 'Function');\n\n            // Vars\n            var self = this,\n                keys = [];\n\n            // Checking\n            if (self.running) { return self; }\n\n            // Overriding\n            keys   = XP.pluck(parser(path, keys) && keys, 'name');\n            method = XP.isBrowser() ? 'on' : method.toLowerCase();\n\n            // Listening\n            if (XP.isBrowser()) {\n                self._adaptee[method](path, function () { callback(XP.zipObject(keys, arguments)); });\n            } else {\n                self._adaptee[method](path, function () { callback(XP.assign(this.req, {params: XP.zipObject(keys, arguments)}), this.res); });\n            }\n\n            return self;\n        },\n\n        /**\n         * TODO DOC\n         *\n         * @method run\n         * @returns {Object}\n         */\n        run: function () {\n\n            // Vars\n            var self = this;\n\n            // Initializing\n            if (!self.running && XP.isBrowser()) { XP.delay(function () { self._adaptee.init('/'); }); }\n\n            // Setting\n            return self;\n        },\n\n        /*********************************************************************/\n\n        /**\n         * TODO DOC\n         *\n         * @property route\n         * @type Array\n         * @readonly\n         */\n        route: {\n            get: function () { return (this.running && this._adaptee.getRoute()) || null; }\n        },\n\n        /**\n         * TODO DOC\n         *\n         * @property running\n         * @type boolean\n         * @readonly\n         */\n        running: {\n            set: function (val) { return this.running || !!val; }\n        },\n\n        /*********************************************************************/\n\n        /**\n         * TODO DOC\n         *\n         * @property _adaptee\n         * @type Object\n         * @private\n         */\n        _adaptee: {\n            enumerable: false,\n            set: function (val) { return this._adaptee || val; },\n            validate: function (val) { return !XP.isObject(val) && 'Object'; }\n        },\n\n        /**\n         * TODO DOC\n         *\n         * @property _server\n         * @type Object\n         * @private\n         */\n        _server: {\n            enumerable: false,\n            set: function (val) { return XP.isDefined(this._server) ? this._server : val; },\n            validate: function (val) { return !XP.isBrowser() && !XP.isObject(val) && 'Object'; }\n        },\n\n        /*********************************************************************/\n\n        // HANDLER\n        _handleRequest: function (req, res) {\n\n            // Vars\n            var self   = this,\n                chunks = [];\n\n            // Listening\n            req.on('data', function (chunk) { chunks.push(chunk); });\n            req.on('end', function () { req.body = XP.join(chunks); });\n\n            // Dispatching\n            self._adaptee.dispatch(req, res, function () {\n                res.writeHead(404);\n                res.end();\n            });\n        }\n    });\n\n}(typeof window !== \"undefined\" ? window : global));\n","\n\n//\n// Generated on Tue Dec 16 2014 12:13:47 GMT+0100 (CET) by Charlie Robbins, Paolo Fragomeni & the Contributors (Using Codesurgeon).\n// Version 1.2.6\n//\n\n(function (exports) {\n\n/*\n * browser.js: Browser specific functionality for director.\n *\n * (C) 2011, Charlie Robbins, Paolo Fragomeni, & the Contributors.\n * MIT LICENSE\n *\n */\n\nvar dloc = document.location;\n\nfunction dlocHashEmpty() {\n  // Non-IE browsers return '' when the address bar shows '#'; Director's logic\n  // assumes both mean empty.\n  return dloc.hash === '' || dloc.hash === '#';\n}\n\nvar listener = {\n  mode: 'modern',\n  hash: dloc.hash,\n  history: false,\n\n  check: function () {\n    var h = dloc.hash;\n    if (h != this.hash) {\n      this.hash = h;\n      this.onHashChanged();\n    }\n  },\n\n  fire: function () {\n    if (this.mode === 'modern') {\n      this.history === true ? window.onpopstate() : window.onhashchange();\n    }\n    else {\n      this.onHashChanged();\n    }\n  },\n\n  init: function (fn, history) {\n    var self = this;\n    this.history = history;\n\n    if (!Router.listeners) {\n      Router.listeners = [];\n    }\n\n    function onchange(onChangeEvent) {\n      for (var i = 0, l = Router.listeners.length; i < l; i++) {\n        Router.listeners[i](onChangeEvent);\n      }\n    }\n\n    //note IE8 is being counted as 'modern' because it has the hashchange event\n    if ('onhashchange' in window && (document.documentMode === undefined\n      || document.documentMode > 7)) {\n      // At least for now HTML5 history is available for 'modern' browsers only\n      if (this.history === true) {\n        // There is an old bug in Chrome that causes onpopstate to fire even\n        // upon initial page load. Since the handler is run manually in init(),\n        // this would cause Chrome to run it twise. Currently the only\n        // workaround seems to be to set the handler after the initial page load\n        // http://code.google.com/p/chromium/issues/detail?id=63040\n        setTimeout(function() {\n          window.onpopstate = onchange;\n        }, 500);\n      }\n      else {\n        window.onhashchange = onchange;\n      }\n      this.mode = 'modern';\n    }\n    else {\n      //\n      // IE support, based on a concept by Erik Arvidson ...\n      //\n      var frame = document.createElement('iframe');\n      frame.id = 'state-frame';\n      frame.style.display = 'none';\n      document.body.appendChild(frame);\n      this.writeFrame('');\n\n      if ('onpropertychange' in document && 'attachEvent' in document) {\n        document.attachEvent('onpropertychange', function () {\n          if (event.propertyName === 'location') {\n            self.check();\n          }\n        });\n      }\n\n      window.setInterval(function () { self.check(); }, 50);\n\n      this.onHashChanged = onchange;\n      this.mode = 'legacy';\n    }\n\n    Router.listeners.push(fn);\n\n    return this.mode;\n  },\n\n  destroy: function (fn) {\n    if (!Router || !Router.listeners) {\n      return;\n    }\n\n    var listeners = Router.listeners;\n\n    for (var i = listeners.length - 1; i >= 0; i--) {\n      if (listeners[i] === fn) {\n        listeners.splice(i, 1);\n      }\n    }\n  },\n\n  setHash: function (s) {\n    // Mozilla always adds an entry to the history\n    if (this.mode === 'legacy') {\n      this.writeFrame(s);\n    }\n\n    if (this.history === true) {\n      window.history.pushState({}, document.title, s);\n      // Fire an onpopstate event manually since pushing does not obviously\n      // trigger the pop event.\n      this.fire();\n    } else {\n      dloc.hash = (s[0] === '/') ? s : '/' + s;\n    }\n    return this;\n  },\n\n  writeFrame: function (s) {\n    // IE support...\n    var f = document.getElementById('state-frame');\n    var d = f.contentDocument || f.contentWindow.document;\n    d.open();\n    d.write(\"<script>_hash = '\" + s + \"'; onload = parent.listener.syncHash;<script>\");\n    d.close();\n  },\n\n  syncHash: function () {\n    // IE support...\n    var s = this._hash;\n    if (s != dloc.hash) {\n      dloc.hash = s;\n    }\n    return this;\n  },\n\n  onHashChanged: function () {}\n};\n\nvar Router = exports.Router = function (routes) {\n  if (!(this instanceof Router)) return new Router(routes);\n\n  this.params   = {};\n  this.routes   = {};\n  this.methods  = ['on', 'once', 'after', 'before'];\n  this.scope    = [];\n  this._methods = {};\n\n  this._insert = this.insert;\n  this.insert = this.insertEx;\n\n  this.historySupport = (window.history != null ? window.history.pushState : null) != null\n\n  this.configure();\n  this.mount(routes || {});\n};\n\nRouter.prototype.init = function (r) {\n  var self = this\n    , routeTo;\n  this.handler = function(onChangeEvent) {\n    var newURL = onChangeEvent && onChangeEvent.newURL || window.location.hash;\n    var url = self.history === true ? self.getPath() : newURL.replace(/.*#/, '');\n    self.dispatch('on', url.charAt(0) === '/' ? url : '/' + url);\n  };\n\n  listener.init(this.handler, this.history);\n\n  if (this.history === false) {\n    if (dlocHashEmpty() && r) {\n      dloc.hash = r;\n    } else if (!dlocHashEmpty()) {\n      self.dispatch('on', '/' + dloc.hash.replace(/^(#\\/|#|\\/)/, ''));\n    }\n  }\n  else {\n    if (this.convert_hash_in_init) {\n      // Use hash as route\n      routeTo = dlocHashEmpty() && r ? r : !dlocHashEmpty() ? dloc.hash.replace(/^#/, '') : null;\n      if (routeTo) {\n        window.history.replaceState({}, document.title, routeTo);\n      }\n    }\n    else {\n      // Use canonical url\n      routeTo = this.getPath();\n    }\n\n    // Router has been initialized, but due to the chrome bug it will not\n    // yet actually route HTML5 history state changes. Thus, decide if should route.\n    if (routeTo || this.run_in_init === true) {\n      this.handler();\n    }\n  }\n\n  return this;\n};\n\nRouter.prototype.explode = function () {\n  var v = this.history === true ? this.getPath() : dloc.hash;\n  if (v.charAt(1) === '/') { v=v.slice(1) }\n  return v.slice(1, v.length).split(\"/\");\n};\n\nRouter.prototype.setRoute = function (i, v, val) {\n  var url = this.explode();\n\n  if (typeof i === 'number' && typeof v === 'string') {\n    url[i] = v;\n  }\n  else if (typeof val === 'string') {\n    url.splice(i, v, s);\n  }\n  else {\n    url = [i];\n  }\n\n  listener.setHash(url.join('/'));\n  return url;\n};\n\n//\n// ### function insertEx(method, path, route, parent)\n// #### @method {string} Method to insert the specific `route`.\n// #### @path {Array} Parsed path to insert the `route` at.\n// #### @route {Array|function} Route handlers to insert.\n// #### @parent {Object} **Optional** Parent \"routes\" to insert into.\n// insert a callback that will only occur once per the matched route.\n//\nRouter.prototype.insertEx = function(method, path, route, parent) {\n  if (method === \"once\") {\n    method = \"on\";\n    route = function(route) {\n      var once = false;\n      return function() {\n        if (once) return;\n        once = true;\n        return route.apply(this, arguments);\n      };\n    }(route);\n  }\n  return this._insert(method, path, route, parent);\n};\n\nRouter.prototype.getRoute = function (v) {\n  var ret = v;\n\n  if (typeof v === \"number\") {\n    ret = this.explode()[v];\n  }\n  else if (typeof v === \"string\"){\n    var h = this.explode();\n    ret = h.indexOf(v);\n  }\n  else {\n    ret = this.explode();\n  }\n\n  return ret;\n};\n\nRouter.prototype.destroy = function () {\n  listener.destroy(this.handler);\n  return this;\n};\n\nRouter.prototype.getPath = function () {\n  var path = window.location.pathname;\n  if (path.substr(0, 1) !== '/') {\n    path = '/' + path;\n  }\n  return path;\n};\nfunction _every(arr, iterator) {\n  for (var i = 0; i < arr.length; i += 1) {\n    if (iterator(arr[i], i, arr) === false) {\n      return;\n    }\n  }\n}\n\nfunction _flatten(arr) {\n  var flat = [];\n  for (var i = 0, n = arr.length; i < n; i++) {\n    flat = flat.concat(arr[i]);\n  }\n  return flat;\n}\n\nfunction _asyncEverySeries(arr, iterator, callback) {\n  if (!arr.length) {\n    return callback();\n  }\n  var completed = 0;\n  (function iterate() {\n    iterator(arr[completed], function(err) {\n      if (err || err === false) {\n        callback(err);\n        callback = function() {};\n      } else {\n        completed += 1;\n        if (completed === arr.length) {\n          callback();\n        } else {\n          iterate();\n        }\n      }\n    });\n  })();\n}\n\nfunction paramifyString(str, params, mod) {\n  mod = str;\n  for (var param in params) {\n    if (params.hasOwnProperty(param)) {\n      mod = params[param](str);\n      if (mod !== str) {\n        break;\n      }\n    }\n  }\n  return mod === str ? \"([._a-zA-Z0-9-%()]+)\" : mod;\n}\n\nfunction regifyString(str, params) {\n  var matches, last = 0, out = \"\";\n  while (matches = str.substr(last).match(/[^\\w\\d\\- %@&]*\\*[^\\w\\d\\- %@&]*/)) {\n    last = matches.index + matches[0].length;\n    matches[0] = matches[0].replace(/^\\*/, \"([_.()!\\\\ %@&a-zA-Z0-9-]+)\");\n    out += str.substr(0, matches.index) + matches[0];\n  }\n  str = out += str.substr(last);\n  var captures = str.match(/:([^\\/]+)/ig), capture, length;\n  if (captures) {\n    length = captures.length;\n    for (var i = 0; i < length; i++) {\n      capture = captures[i];\n      if (capture.slice(0, 2) === \"::\") {\n        str = capture.slice(1);\n      } else {\n        str = str.replace(capture, paramifyString(capture, params));\n      }\n    }\n  }\n  return str;\n}\n\nfunction terminator(routes, delimiter, start, stop) {\n  var last = 0, left = 0, right = 0, start = (start || \"(\").toString(), stop = (stop || \")\").toString(), i;\n  for (i = 0; i < routes.length; i++) {\n    var chunk = routes[i];\n    if (chunk.indexOf(start, last) > chunk.indexOf(stop, last) || ~chunk.indexOf(start, last) && !~chunk.indexOf(stop, last) || !~chunk.indexOf(start, last) && ~chunk.indexOf(stop, last)) {\n      left = chunk.indexOf(start, last);\n      right = chunk.indexOf(stop, last);\n      if (~left && !~right || !~left && ~right) {\n        var tmp = routes.slice(0, (i || 1) + 1).join(delimiter);\n        routes = [ tmp ].concat(routes.slice((i || 1) + 1));\n      }\n      last = (right > left ? right : left) + 1;\n      i = 0;\n    } else {\n      last = 0;\n    }\n  }\n  return routes;\n}\n\nvar QUERY_SEPARATOR = /\\?.*/;\n\nRouter.prototype.configure = function(options) {\n  options = options || {};\n  for (var i = 0; i < this.methods.length; i++) {\n    this._methods[this.methods[i]] = true;\n  }\n  this.recurse = options.recurse || this.recurse || false;\n  this.async = options.async || false;\n  this.delimiter = options.delimiter || \"/\";\n  this.strict = typeof options.strict === \"undefined\" ? true : options.strict;\n  this.notfound = options.notfound;\n  this.resource = options.resource;\n  this.history = options.html5history && this.historySupport || false;\n  this.run_in_init = this.history === true && options.run_handler_in_init !== false;\n  this.convert_hash_in_init = this.history === true && options.convert_hash_in_init !== false;\n  this.every = {\n    after: options.after || null,\n    before: options.before || null,\n    on: options.on || null\n  };\n  return this;\n};\n\nRouter.prototype.param = function(token, matcher) {\n  if (token[0] !== \":\") {\n    token = \":\" + token;\n  }\n  var compiled = new RegExp(token, \"g\");\n  this.params[token] = function(str) {\n    return str.replace(compiled, matcher.source || matcher);\n  };\n  return this;\n};\n\nRouter.prototype.on = Router.prototype.route = function(method, path, route) {\n  var self = this;\n  if (!route && typeof path == \"function\") {\n    route = path;\n    path = method;\n    method = \"on\";\n  }\n  if (Array.isArray(path)) {\n    return path.forEach(function(p) {\n      self.on(method, p, route);\n    });\n  }\n  if (path.source) {\n    path = path.source.replace(/\\\\\\//ig, \"/\");\n  }\n  if (Array.isArray(method)) {\n    return method.forEach(function(m) {\n      self.on(m.toLowerCase(), path, route);\n    });\n  }\n  path = path.split(new RegExp(this.delimiter));\n  path = terminator(path, this.delimiter);\n  this.insert(method, this.scope.concat(path), route);\n};\n\nRouter.prototype.path = function(path, routesFn) {\n  var self = this, length = this.scope.length;\n  if (path.source) {\n    path = path.source.replace(/\\\\\\//ig, \"/\");\n  }\n  path = path.split(new RegExp(this.delimiter));\n  path = terminator(path, this.delimiter);\n  this.scope = this.scope.concat(path);\n  routesFn.call(this, this);\n  this.scope.splice(length, path.length);\n};\n\nRouter.prototype.dispatch = function(method, path, callback) {\n  var self = this, fns = this.traverse(method, path.replace(QUERY_SEPARATOR, \"\"), this.routes, \"\"), invoked = this._invoked, after;\n  this._invoked = true;\n  if (!fns || fns.length === 0) {\n    this.last = [];\n    if (typeof this.notfound === \"function\") {\n      this.invoke([ this.notfound ], {\n        method: method,\n        path: path\n      }, callback);\n    }\n    return false;\n  }\n  if (this.recurse === \"forward\") {\n    fns = fns.reverse();\n  }\n  function updateAndInvoke() {\n    self.last = fns.after;\n    self.invoke(self.runlist(fns), self, callback);\n  }\n  after = this.every && this.every.after ? [ this.every.after ].concat(this.last) : [ this.last ];\n  if (after && after.length > 0 && invoked) {\n    if (this.async) {\n      this.invoke(after, this, updateAndInvoke);\n    } else {\n      this.invoke(after, this);\n      updateAndInvoke();\n    }\n    return true;\n  }\n  updateAndInvoke();\n  return true;\n};\n\nRouter.prototype.invoke = function(fns, thisArg, callback) {\n  var self = this;\n  var apply;\n  if (this.async) {\n    apply = function(fn, next) {\n      if (Array.isArray(fn)) {\n        return _asyncEverySeries(fn, apply, next);\n      } else if (typeof fn == \"function\") {\n        fn.apply(thisArg, (fns.captures || []).concat(next));\n      }\n    };\n    _asyncEverySeries(fns, apply, function() {\n      if (callback) {\n        callback.apply(thisArg, arguments);\n      }\n    });\n  } else {\n    apply = function(fn) {\n      if (Array.isArray(fn)) {\n        return _every(fn, apply);\n      } else if (typeof fn === \"function\") {\n        return fn.apply(thisArg, fns.captures || []);\n      } else if (typeof fn === \"string\" && self.resource) {\n        self.resource[fn].apply(thisArg, fns.captures || []);\n      }\n    };\n    _every(fns, apply);\n  }\n};\n\nRouter.prototype.traverse = function(method, path, routes, regexp, filter) {\n  var fns = [], current, exact, match, next, that;\n  function filterRoutes(routes) {\n    if (!filter) {\n      return routes;\n    }\n    function deepCopy(source) {\n      var result = [];\n      for (var i = 0; i < source.length; i++) {\n        result[i] = Array.isArray(source[i]) ? deepCopy(source[i]) : source[i];\n      }\n      return result;\n    }\n    function applyFilter(fns) {\n      for (var i = fns.length - 1; i >= 0; i--) {\n        if (Array.isArray(fns[i])) {\n          applyFilter(fns[i]);\n          if (fns[i].length === 0) {\n            fns.splice(i, 1);\n          }\n        } else {\n          if (!filter(fns[i])) {\n            fns.splice(i, 1);\n          }\n        }\n      }\n    }\n    var newRoutes = deepCopy(routes);\n    newRoutes.matched = routes.matched;\n    newRoutes.captures = routes.captures;\n    newRoutes.after = routes.after.filter(filter);\n    applyFilter(newRoutes);\n    return newRoutes;\n  }\n  if (path === this.delimiter && routes[method]) {\n    next = [ [ routes.before, routes[method] ].filter(Boolean) ];\n    next.after = [ routes.after ].filter(Boolean);\n    next.matched = true;\n    next.captures = [];\n    return filterRoutes(next);\n  }\n  for (var r in routes) {\n    if (routes.hasOwnProperty(r) && (!this._methods[r] || this._methods[r] && typeof routes[r] === \"object\" && !Array.isArray(routes[r]))) {\n      current = exact = regexp + this.delimiter + r;\n      if (!this.strict) {\n        exact += \"[\" + this.delimiter + \"]?\";\n      }\n      match = path.match(new RegExp(\"^\" + exact));\n      if (!match) {\n        continue;\n      }\n      if (match[0] && match[0] == path && routes[r][method]) {\n        next = [ [ routes[r].before, routes[r][method] ].filter(Boolean) ];\n        next.after = [ routes[r].after ].filter(Boolean);\n        next.matched = true;\n        next.captures = match.slice(1);\n        if (this.recurse && routes === this.routes) {\n          next.push([ routes.before, routes.on ].filter(Boolean));\n          next.after = next.after.concat([ routes.after ].filter(Boolean));\n        }\n        return filterRoutes(next);\n      }\n      next = this.traverse(method, path, routes[r], current);\n      if (next.matched) {\n        if (next.length > 0) {\n          fns = fns.concat(next);\n        }\n        if (this.recurse) {\n          fns.push([ routes[r].before, routes[r].on ].filter(Boolean));\n          next.after = next.after.concat([ routes[r].after ].filter(Boolean));\n          if (routes === this.routes) {\n            fns.push([ routes[\"before\"], routes[\"on\"] ].filter(Boolean));\n            next.after = next.after.concat([ routes[\"after\"] ].filter(Boolean));\n          }\n        }\n        fns.matched = true;\n        fns.captures = next.captures;\n        fns.after = next.after;\n        return filterRoutes(fns);\n      }\n    }\n  }\n  return false;\n};\n\nRouter.prototype.insert = function(method, path, route, parent) {\n  var methodType, parentType, isArray, nested, part;\n  path = path.filter(function(p) {\n    return p && p.length > 0;\n  });\n  parent = parent || this.routes;\n  part = path.shift();\n  if (/\\:|\\*/.test(part) && !/\\\\d|\\\\w/.test(part)) {\n    part = regifyString(part, this.params);\n  }\n  if (path.length > 0) {\n    parent[part] = parent[part] || {};\n    return this.insert(method, path, route, parent[part]);\n  }\n  if (!part && !path.length && parent === this.routes) {\n    methodType = typeof parent[method];\n    switch (methodType) {\n     case \"function\":\n      parent[method] = [ parent[method], route ];\n      return;\n     case \"object\":\n      parent[method].push(route);\n      return;\n     case \"undefined\":\n      parent[method] = route;\n      return;\n    }\n    return;\n  }\n  parentType = typeof parent[part];\n  isArray = Array.isArray(parent[part]);\n  if (parent[part] && !isArray && parentType == \"object\") {\n    methodType = typeof parent[part][method];\n    switch (methodType) {\n     case \"function\":\n      parent[part][method] = [ parent[part][method], route ];\n      return;\n     case \"object\":\n      parent[part][method].push(route);\n      return;\n     case \"undefined\":\n      parent[part][method] = route;\n      return;\n    }\n  } else if (parentType == \"undefined\") {\n    nested = {};\n    nested[method] = route;\n    parent[part] = nested;\n    return;\n  }\n  throw new Error(\"Invalid route context: \" + parentType);\n};\n\n\n\nRouter.prototype.extend = function(methods) {\n  var self = this, len = methods.length, i;\n  function extend(method) {\n    self._methods[method] = true;\n    self[method] = function() {\n      var extra = arguments.length === 1 ? [ method, \"\" ] : [ method ];\n      self.on.apply(self, extra.concat(Array.prototype.slice.call(arguments)));\n    };\n  }\n  for (i = 0; i < len; i++) {\n    extend(methods[i]);\n  }\n};\n\nRouter.prototype.runlist = function(fns) {\n  var runlist = this.every && this.every.before ? [ this.every.before ].concat(_flatten(fns)) : _flatten(fns);\n  if (this.every && this.every.on) {\n    runlist.push(this.every.on);\n  }\n  runlist.captures = fns.captures;\n  runlist.source = fns.source;\n  return runlist;\n};\n\nRouter.prototype.mount = function(routes, path) {\n  if (!routes || typeof routes !== \"object\" || Array.isArray(routes)) {\n    return;\n  }\n  var self = this;\n  path = path || [];\n  if (!Array.isArray(path)) {\n    path = path.split(self.delimiter);\n  }\n  function insertOrMount(route, local) {\n    var rename = route, parts = route.split(self.delimiter), routeType = typeof routes[route], isRoute = parts[0] === \"\" || !self._methods[parts[0]], event = isRoute ? \"on\" : rename;\n    if (isRoute) {\n      rename = rename.slice((rename.match(new RegExp(\"^\" + self.delimiter)) || [ \"\" ])[0].length);\n      parts.shift();\n    }\n    if (isRoute && routeType === \"object\" && !Array.isArray(routes[route])) {\n      local = local.concat(parts);\n      self.mount(routes[route], local);\n      return;\n    }\n    if (isRoute) {\n      local = local.concat(rename.split(self.delimiter));\n      local = terminator(local, self.delimiter);\n    }\n    self.insert(event, local, routes[route]);\n  }\n  for (var route in routes) {\n    if (routes.hasOwnProperty(route)) {\n      insertOrMount(route, path.slice(0));\n    }\n  }\n};\n\n\n\n}(typeof exports === \"object\" ? exports : window));","var isarray = require('isarray')\n\n/**\n * Expose `pathToRegexp`.\n */\nmodule.exports = pathToRegexp\nmodule.exports.parse = parse\nmodule.exports.compile = compile\nmodule.exports.tokensToFunction = tokensToFunction\nmodule.exports.tokensToRegExp = tokensToRegExp\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n  // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n  // \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n  '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^()])+)\\\\))([+*?])?|(\\\\*))'\n].join('|'), 'g')\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {String} str\n * @return {Array}\n */\nfunction parse (str) {\n  var tokens = []\n  var key = 0\n  var index = 0\n  var path = ''\n  var res\n\n  while ((res = PATH_REGEXP.exec(str)) != null) {\n    var m = res[0]\n    var escaped = res[1]\n    var offset = res.index\n    path += str.slice(index, offset)\n    index = offset + m.length\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1]\n      continue\n    }\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path)\n      path = ''\n    }\n\n    var prefix = res[2]\n    var name = res[3]\n    var capture = res[4]\n    var group = res[5]\n    var suffix = res[6]\n    var asterisk = res[7]\n\n    var repeat = suffix === '+' || suffix === '*'\n    var optional = suffix === '?' || suffix === '*'\n    var delimiter = prefix || '/'\n    var pattern = capture || group || (asterisk ? '.*' : '[^' + delimiter + ']+?')\n\n    tokens.push({\n      name: name || key++,\n      prefix: prefix || '',\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      pattern: escapeGroup(pattern)\n    })\n  }\n\n  // Match any characters still remaining.\n  if (index < str.length) {\n    path += str.substr(index)\n  }\n\n  // If the path exists, push it onto the end.\n  if (path) {\n    tokens.push(path)\n  }\n\n  return tokens\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {String}   str\n * @return {Function}\n */\nfunction compile (str) {\n  return tokensToFunction(parse(str))\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction (tokens) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length)\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^' + tokens[i].pattern + '$')\n    }\n  }\n\n  return function (obj) {\n    var path = ''\n    var data = obj || {}\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i]\n\n      if (typeof token === 'string') {\n        path += token\n\n        continue\n      }\n\n      var value = data[token.name]\n      var segment\n\n      if (value == null) {\n        if (token.optional) {\n          continue\n        } else {\n          throw new TypeError('Expected \"' + token.name + '\" to be defined')\n        }\n      }\n\n      if (isarray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received \"' + value + '\"')\n        }\n\n        if (value.length === 0) {\n          if (token.optional) {\n            continue\n          } else {\n            throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n          }\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encodeURIComponent(value[j])\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment\n        }\n\n        continue\n      }\n\n      segment = encodeURIComponent(value)\n\n      if (!matches[i].test(segment)) {\n        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n      }\n\n      path += token.prefix + segment\n    }\n\n    return path\n  }\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {String} str\n * @return {String}\n */\nfunction escapeString (str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|\\/])/g, '\\\\$1')\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {String} group\n * @return {String}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$\\/()])/g, '\\\\$1')\n}\n\n/**\n * Attach the keys as a property of the regexp.\n *\n * @param  {RegExp} re\n * @param  {Array}  keys\n * @return {RegExp}\n */\nfunction attachKeys (re, keys) {\n  re.keys = keys\n  return re\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {String}\n */\nfunction flags (options) {\n  return options.sensitive ? '' : 'i'\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {RegExp} path\n * @param  {Array}  keys\n * @return {RegExp}\n */\nfunction regexpToRegexp (path, keys) {\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g)\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        pattern: null\n      })\n    }\n  }\n\n  return attachKeys(path, keys)\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {Array}  path\n * @param  {Array}  keys\n * @param  {Object} options\n * @return {RegExp}\n */\nfunction arrayToRegexp (path, keys, options) {\n  var parts = []\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source)\n  }\n\n  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))\n\n  return attachKeys(regexp, keys)\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {String} path\n * @param  {Array}  keys\n * @param  {Object} options\n * @return {RegExp}\n */\nfunction stringToRegexp (path, keys, options) {\n  var tokens = parse(path)\n  var re = tokensToRegExp(tokens, options)\n\n  // Attach keys back to the regexp.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] !== 'string') {\n      keys.push(tokens[i])\n    }\n  }\n\n  return attachKeys(re, keys)\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {Array}  tokens\n * @param  {Array}  keys\n * @param  {Object} options\n * @return {RegExp}\n */\nfunction tokensToRegExp (tokens, options) {\n  options = options || {}\n\n  var strict = options.strict\n  var end = options.end !== false\n  var route = ''\n  var lastToken = tokens[tokens.length - 1]\n  var endsWithSlash = typeof lastToken === 'string' && /\\/$/.test(lastToken)\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n\n    if (typeof token === 'string') {\n      route += escapeString(token)\n    } else {\n      var prefix = escapeString(token.prefix)\n      var capture = token.pattern\n\n      if (token.repeat) {\n        capture += '(?:' + prefix + capture + ')*'\n      }\n\n      if (token.optional) {\n        if (prefix) {\n          capture = '(?:' + prefix + '(' + capture + '))?'\n        } else {\n          capture = '(' + capture + ')?'\n        }\n      } else {\n        capture = prefix + '(' + capture + ')'\n      }\n\n      route += capture\n    }\n  }\n\n  // In non-strict mode we allow a slash at the end of match. If the path to\n  // match already ends with a slash, we remove it for consistency. The slash\n  // is valid at the end of a path match, not in the middle. This is important\n  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n  if (!strict) {\n    route = (endsWithSlash ? route.slice(0, -2) : route) + '(?:\\\\/(?=$))?'\n  }\n\n  if (end) {\n    route += '$'\n  } else {\n    // In non-ending mode, we need the capturing groups to match as much as\n    // possible by using a positive lookahead to the end or next path segment.\n    route += strict && endsWithSlash ? '' : '(?=\\\\/|$)'\n  }\n\n  return new RegExp('^' + route, flags(options))\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(String|RegExp|Array)} path\n * @param  {Array}                 [keys]\n * @param  {Object}                [options]\n * @return {RegExp}\n */\nfunction pathToRegexp (path, keys, options) {\n  keys = keys || []\n\n  if (!isarray(keys)) {\n    options = keys\n    keys = []\n  } else if (!options) {\n    options = {}\n  }\n\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, keys, options)\n  }\n\n  if (isarray(path)) {\n    return arrayToRegexp(path, keys, options)\n  }\n\n  return stringToRegexp(path, keys, options)\n}\n","module.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n"]}